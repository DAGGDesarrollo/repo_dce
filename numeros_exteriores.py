# -*- coding: utf-8 -*-
"""
/***************************************************************************
Números Exteriores - INE
                                 A QGIS plugin
 Este Plugin otorga herramientas para el procesamiento, depuración y actualización 
 de los números exteriores pertenecientes a la cartografía electoral generada para 
 la Dirección de Cartografía Electoral del Instituto Nacional Electoral (INE).
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-04-25
        git sha              : $Format:%H$
        copyright            : (C) 2023 by INE, Direccion de Cartografia Electoral, 
                                Luis Enrique Cortés
        email                : enrique.cortes@ine.mx
        version              : 3.0
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
#from PyQt5.QtCore import QSettings, QTranslator, qVersion, Qt, QCoreApplication, QVariant
from qgis.PyQt.QtCore import QSettings, QTranslator,qVersion, Qt, QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtGui import QColor
from qgis.PyQt.QtWidgets import QAction, QMessageBox, QProgressBar, QSizePolicy, QWidget, QApplication

#from PyQt5.QtWidgets import QAction, QMessageBox, QProgressBar
from qgis.core import *
from qgis.core import QgsProject
from qgis.core import QgsVectorLayer, QgsDataSourceUri
from qgis.utils import *
from PyQt5 import QtTest
from PyQt5.QtWidgets import *

#from PyQt4 import QtGui

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
#from .field_viewer_dialog import FieldViewerDialog
#from .field_viewer_dialog import FieldViewerDialogBase
from .numeros_exteriores_dockwidget import numeros_exterioresDockWidget
import os
import os.path


#Importa módulo regex para expresiones regulares
import re

# load the adapter
import psycopg2
# load the psycopg extras module
import psycopg2.extras

from qgis.core import QgsApplication;
from qgis.gui import QgsMapCanvas;


class numeros_exteriores:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'numeros_exteriores_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Números Exteriores')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'Números Exteriores')
        self.toolbar.setObjectName(u'Números Exteriores')

        self.campo01 = ""
        self.conectado = False
        self.ultimaEntidad = ""
        self.ultimoMunicipio = ""


        self.servidorPrueba = "172.19.122.145"
        self.baseDatosPrueba = "bged01_desarrollo"

        self.servidor09 = "10.9.0.173"
        self.baseDatos09 = "bged09"

        self.servidor28 = "10.68.0.103"
        self.baseDatos28 = "bged28"

        self.servidor = self.servidorPrueba
        self.baseDatos = self.baseDatosPrueba


        #print "** INITIALIZING numeros_exteriores"

        self.pluginIsActive = False
        self.dockwidget = None

        #self.Sector = [],[]
        #self.SectorNombre = []
        #self.SectorRInicial = []
        #self.SectorRFinal = []
        #self.SectorRIntervalo = []

        self.SectorNombre = ['', '', '']
        self.SectorRInicial = ['', '', '']
        self.SectorRFinal = ['', '', '']
        self.SectorRIntervalo = ['', '', '']


        self.Sector1 = []
        self.Sector2 = []
        self.Sector3 = []

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('numeros_exteriores', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """



        #linea agregada al codigo original
        self.dockwidget = numeros_exterioresDockWidget() #Se instancia la clase del cuadro de dialogo
        #self.dockwidget = PruebaScrollDockWidget() #Se instancia la clase del cuadro de dialogo
        #self.dockwidget = FieldViewerDialogBase() #Se instancia la clase del cuadro de dialogo



        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/numeros_exteriores/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Números Exteriores'),
            callback=self.run,
            parent=self.iface.mainWindow())

    #--------------------------------------------------------------------------



        self.dockwidget.btnConectar.clicked.connect(self.btnConectar_accion)
        self.dockwidget.btnDesconectar.clicked.connect(self.btnDesconectar_accion)

        self.dockwidget.cveMunicipio.currentIndexChanged.connect(self.on_cveMunicipio_changed)
        self.dockwidget.btnObtenerArea.clicked.connect(self.btnObtenerArea_accion)

        self.dockwidget.btnRecomendaciones.clicked.connect(self.btnRecomendaciones_accion)

        self.dockwidget.btnMostrar.clicked.connect(self.btnMostrar_accion)
        self.dockwidget.btnSugerir.clicked.connect(self.btnSugerir_accion)
        
        self.dockwidget.tmaxFont.clicked.connect(self.tmaxFont)
        self.dockwidget.tmedFont.clicked.connect(self.tmedFont)
        self.dockwidget.tminFont.clicked.connect(self.tminFont)

        self.dockwidget.btnInvertir.clicked.connect(self.btnInvertir)
        self.dockwidget.btnCrearCadena.clicked.connect(self.btnCrearCadena)
        self.dockwidget.btnGuardar.clicked.connect(self.btnGuardar)
        self.dockwidget.btnLimpiarIntervalo.clicked.connect(self.btnLimpiarIntervalo)
        
        self.dockwidget.btnIdentificar10.clicked.connect(self.btnIdentificar10_accion)
        self.dockwidget.btnIdentificar20.clicked.connect(self.btnIdentificar20_accion)
        self.dockwidget.btnIdentificar10.clicked.connect(self.btnIdentificar10_accion)
        self.dockwidget.btndistUsuario.clicked.connect(self.btndistUsuario_accion)

        self.dockwidget.cveSector.currentIndexChanged.connect(self.cveSector_changed)
        self.dockwidget.btnAsignarSector.clicked.connect(self.btnAsignarSector_accion)
        self.dockwidget.btnEliminarSector.clicked.connect(self.btnEliminarSector_accion)

        self.dockwidget.btnCrearCadena_2.clicked.connect(self.btnCrearCadena_2_accion)
        
        #self.dockwidget.btnCancelar.clicked.connect(self.btnCancelar_accion)


    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING NUMEROS_EXTERIORES"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD numeros_exteriores"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&numeros_exteriores'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    #--------------------------------------------------------------------------

    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            #print "** STARTING PruebaScroll"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = numeros_exterioresDockWidget()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            self.dockwidget.show()

            if self.dockwidget.cveEntidad.count() == 0 :

                for entidad in range(1,33):
                    self.dockwidget.cveEntidad.addItem(str(entidad).zfill(2))

                    #self.iface.messageBar().pushMessage("Datos entidad  ", str(entidad))
                    #mun_num = str(row[0]) + " : " + row[1]
                    #sec_num = str(row[1])
            
                #self.iface.messageBar().pushMessage("Mensaje", "Se ejecuto el llenado del combo entidad")
                #QMessageBox.warning(self.iface.mainWindow(), "Aviso", "Se ejecuto el llenado del combo entidad")

            self.dockwidget.btnDesconectar.setEnabled(False)
            #self.dockwidget.txtServidor.setText("172.19.122.145")

            #Crear arreglo general con variables por sector, Inicio, Fin e Intervalo
            #para posteriormente generar cadena completa
            sectores = [1, 2, 3]
            #if self.dockwidget.cveSector.count() == 0 :

            for sector in sectores:
                #item = str(sector).zfill(2)
                item = str(sector)
                self.dockwidget.cveSector.addItem(item)     

    #lineas agregadas al codigo original
    def btnConectar_accion(self):
        #pass
        #Probando funcion base local 
        #self.dockwidget.txtUsuario.setText("postgres")
        #self.dockwidget.txtClave.setText("svm")
        
        #verificar si se tienen rasgos cargados previo a la conexion
        if self.conectado == True:
            return
        
        #Probando funcion base remota Samge 
        #self.dockwidget.txtUsuario.setText(self.usuarioGral)
        #self.dockwidget.txtClave.setText(self.passwordGral)
        
        
        usr = self.dockwidget.txtUsuario.text()
        pwd = self.dockwidget.txtClave.text()
        
        #self.baseDatos = "bged" + self.dockwidget.cveEntidad.currentText() + "_desarrollo"
        self.baseDatos = "bged" + self.dockwidget.cveEntidad.currentText()
        self.servidor = self.dockwidget.txtServidor.text()

        #self.iface.messageBar().pushMessage("Mensaje", "BD: " + self.baseDatos)


        #prueba = "Hola como estas?"
        #self.iface.messageBar().pushMessage("Mensaje", usr)
        
        if usr is NULL or usr == "" or usr.isspace():
            # # the string is empty

            #self.iface.messageBar().pushMessage("Mensaje", "Introduce el usuario")
            QMessageBox.warning(self.iface.mainWindow(), "Aviso", "No fue posible ingresar a la base, revise sus credenciales.")
            return None     #Realmente sale de la funcion
            
        if pwd is NULL or pwd == "" or pwd.isspace():
            # # the string is empty

            #self.iface.messageBar().pushMessage("Mensaje", "Introduce la clave")
            QMessageBox.warning(self.iface.mainWindow(), "Aviso", "No fue posible ingresar a la base, revise sus credenciales.")
            return None
        
        # if len(usr) == 0:
            # self.iface.messageBar().pushMessage("Mensaje", "Introduce el usuario")
            # return false
        # if len(pwd) == 0:
            # self.iface.messageBar().pushMessage("Mensaje", "Introduce la clave")
            # return false
                
        try:
            
            usr = self.dockwidget.txtUsuario.text()
            pwd = self.dockwidget.txtClave.text()
            
            uri = QgsDataSourceUri()
            # set host name, port, database name, username and password
            uri.setConnection(self.servidor, "5432", self.baseDatos, usr, pwd)
            # set database schema, table name, geometry column and optionally
            # subset (WHERE clause)


            ##Cargar capas
            #uri.setDataSource("bged", "manzana", "geom")
            #vlayerM = QgsVectorLayer(uri.uri(False), "Manzana", "postgres")
            #QgsProject.instance().addMapLayer(vlayerM)

            #uri.setDataSource("bged", "vialidad", "geom")
            #vlayerV = QgsVectorLayer(uri.uri(False), "Vialidad", "postgres")
            #QgsProject.instance().addMapLayer(vlayerV)

            ##Consulta de numeros exteriores con campos nulos
            ##uri.setDataSource("bged", "numeros_exteriores", "geom", "manzana is not null")
            #uri.setDataSource("bged", "numeros_exteriores", "geom")
            #vlayerNE = QgsVectorLayer(uri.uri(False), "NumerosExteriores", "postgres")
            #QgsProject.instance().addMapLayer(vlayerNE)


            #Codigo ejemplo para conexion y consulta con base
            #uri.setConnection("localhost", "5432", "myBase", "myUser", "myPassword")
            #sql = 'SELECT * FROM public.tableA a INNER JOIN public.tableB b ON st_intersects(a.geom, b.geom) WHERE a.name LIKE \'Example\' AND b.name LIKE \'Something\''
            #sql = 'SELECT a.idA, a.geom, a.name FROM public.tableA a INNER JOIN public.tableB b ON st_intersects(a.geom, b.geom) WHERE a.name LIKE \'Example\' AND b.name LIKE \'Something\''
            #uri.setDataSource('', f'({sql})', 'geom', '', 'idA')
            #vlayer = iface.addVectorLayer(uri.uri(), 'myLayer','postgres')            

            #Codigo para cargar registros de municipios
            #Abrir base
            usr = self.dockwidget.txtUsuario.text()
            pwd = self.dockwidget.txtClave.text()
            
            #localhost
            #conn = psycopg2.connect(database="ECEG", user=usr, password=pwd, host="localhost", port="5432")
            #remote Samge bged 
            conn = psycopg2.connect(database=self.baseDatos, user=usr, password=pwd, host=self.servidor, port="5432")
        
            with conn:
                #qry_c = """SELECT * from "01"."SECCION_INE";"""
                #qry_c = "SELECT * from bged.numeros_exteriores where id = %s;" 
                qry_c = "SELECT municipio, nombre from bged.municipio order by municipio asc;"
                data_c = (self.campo01, )
                with conn.cursor() as curs:
                    #self.iface.messageBar().pushMessage("Mensaje", "Se llego al codigo para crear la consulta")
                    #curs.execute(qry_c, data_c)
                    curs.execute(qry_c)
                    #self.iface.messageBar().pushMessage("Mensaje", "Se ejecuto la consulta")
                    #result = curs.fetchone()
                    #if result == None:
                        #QMessageBox.information(self.iface.mainWindow(), "No hay extracción","No hay elementos que importar...")
                        #return
                    #else:
                    n = 1
                    rows = curs.fetchall() #one row
                    for row in rows:
                        #self.iface.messageBar().pushMessage("Datos row  ", str(row[0]))
                        idname = str(row[0]) + " : " + row[1].title()
                        self.dockwidget.cveMunicipio.addItem(idname)
                        n=n+1

                    #self.iface.messageBar().pushMessage("Combo box de municipio tiene cargado total de items: ", str(n))
                curs.close()

            conn.close()


            
            #self.iface.btnDeconectar.IsEnabled
            self.dockwidget.btnDesconectar.setEnabled(True)
            self.dockwidget.btnConectar.setEnabled(False)
            self.conectado = True

            #self.dockwidget.cveEntidad.setCurrentText("")
            self.dockwidget.txtServidor.setEnabled(False)
            self.dockwidget.cveEntidad.setEnabled(False)
            self.dockwidget.txtUsuario.setEnabled(False)
            self.dockwidget.txtClave.setEnabled(False)
            #self.dockwidget.btnConectar.setEnabled(False)

            if usr == 'postgres':
                QMessageBox.information(self.iface.mainWindow(),'Aviso',"Se realizó la conexión con éxito...\nIP: " + self.servidor + "\nBase de datos: " + self.baseDatos + "\nBienvenido Admin")
            else:
                QMessageBox.information(self.iface.mainWindow(), "Aviso", "Se realizó la conexión con éxito...\nIP: " + self.servidor + "\nBase de datos: " + self.baseDatos + "\nBienvenido " + usr.split(".")[0].title())
            

            #print ("I was able to connect to the database")
            return None
        except:
            self.iface.messageBar().pushMessage("Mensaje", "No se logró ingresar a la Base.")
            QMessageBox.warning(self.iface.mainWindow(), "Aviso", "No fue posible ingresar a la base, revise los datos, su conexión de red o sus credenciales.")
            #print ("I am unable to connect to the database")
            #self.dockwidget.txtUsuario.setText("")    
            #self.dockwidget.txtClave.setText("")
            return None
        
    
         
    def btnDesconectar_accion(self):

        usuario = self.dockwidget.txtUsuario.text()
        buttonReply = QMessageBox.question(self.iface.mainWindow(), 'Atención', "¿Confirma que quiere cerrar su sesión?", QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
        if buttonReply == QMessageBox.Yes:
            if self.conectado == True:

                self.ultimaEntidad = self.dockwidget.cveEntidad.currentText()

                self.dockwidget.txtServidor.setText("")
                self.dockwidget.txtUsuario.setText("")
                self.dockwidget.txtClave.setText("")

                self.dockwidget.idVialidad_original.setText("")
                self.dockwidget.idManzana_original.setText("")

                self.dockwidget.txtRinicial.setText("")
                self.dockwidget.txtRfinal.setText("")
                self.dockwidget.txtRIntervalo.setText("")

                self.dockwidget.txtServidor.setEnabled(True)
                self.dockwidget.cveEntidad.setEnabled(True)
                self.dockwidget.txtUsuario.setEnabled(True)
                self.dockwidget.txtClave.setEnabled(True)

                self.dockwidget.cveMunicipio.clear()
                self.dockwidget.cveSeccion.clear()

                self.dockwidget.btnDesconectar.setEnabled(False)
                self.dockwidget.btnConectar.setEnabled(True)      

                self.conectado = False
        else:
            pass
        self.iface.mainWindow().show()
        if usuario == 'postgres':
            QMessageBox.information(self.iface.mainWindow(),'Información','Se ha cerrado la sesión. \nHasta pronto Admin.')
        else:
            QMessageBox.information(self.iface.mainWindow(),'Información','Se ha cerrado la sesión. \nHasta pronto {0}'.format(usuario.split('.')[0].title()))

    def on_cveMunicipio_changed(self, value):      
        
        self.dockwidget.cveSeccion.clear()   
        
        #self.iface.messageBar().pushMessage("Mensaje", "Se eligio clave de municipio: " + numeroMunicipio)

        #print("combobox changed", value)
        # do your code
        #connect to Municipio table and select register with value (index), take number of municipio
        #use municipio number and create query in seccion table to take a list of seccions belonged to that municipio
        #fill the 2nd combo with the seccion list
        
        
        
        
        try:
        
            if self.dockwidget.cveMunicipio.count() == 0:
                return
    

            numeroMunicipio = str(self.dockwidget.cveMunicipio.currentText().split(" :",1)[0])

            #self.ultimoMunicipio = numeroMunicipio
            #Codigo para cargar registros de seccion
            #Abrir base
            
            
            usr = self.dockwidget.txtUsuario.text()
            pwd = self.dockwidget.txtClave.text()
            
            uri = QgsDataSourceUri()
            # set host name, port, database name, username and password
            uri.setConnection(self.servidor, "5432", self.baseDatos, usr, pwd)

            
            #self.iface.messageBar().pushMessage("Mensaje", "Se conecto a la DB para obtener numero de municipio con la clave: " + numeroMunicipio)
            
            #localhost
            #conn = psycopg2.connect(database="ECEG", user=usr, password=pwd, host="localhost", port="5432")
            #remote Samge bged 
            connectDB = psycopg2.connect(database=self.baseDatos, user=usr, password=pwd, host=self.servidor, port="5432")
        
            #self.iface.messageBar().pushMessage("Mensaje", "Conectada")
        
            #with connectDB:
                ##qry_c = """SELECT * from "01"."SECCION_INE";"""
                ##qry_c = "SELECT * from bged.numeros_exteriores where id = %s;" 
                #qry_c = "SELECT municipio, nombre from bged.municipio where municipio = %s order by municipio asc;"
                ##data_c = (self.campo01, )
                #data_c = (value+1, )
                
                #curs = connectDB.cursor()
                ##with connectDB.cursor() as curs:
                #with curs:
                    #self.iface.messageBar().pushMessage("Mensaje", "Se llego al codigo para crear la consulta")
                    #curs.execute(qry_c, data_c)
                    ##curs.execute(qry_c)
                    #self.iface.messageBar().pushMessage("Mensaje", "Se ejecuto la consulta")
                    #result = curs.fetchone()
                    ##if result == None:
                        ##QMessageBox.information(self.iface.mainWindow(), "No hay extraccion","No hay elementos que importar...")
                        ##return
                    ##else:
                    #self.iface.messageBar().pushMessage("Mensaje", "Se tiene municipio clave: " + str(result[0]))
                    #mun_rows = curs.fetchall()
                    ##self.iface.messageBar().pushMessage("Mensaje", "Se tiene conteo de: " + len(mun_rows))

                    #for row in mun_rows:
                        #self.iface.messageBar().pushMessage("Datos municipio row  ", str(row[0]))
                        ##mun_num = str(row[0]) + " : " + row[1]
                        ##mun_num = row[0]
                        ##self.dockwidget.cveMunicipio.addItem(mun_num)

                #curs.close()
            #connectDB.close()

            
            conn = psycopg2.connect(database=self.baseDatos, user=usr, password=pwd, host=self.servidor, port="5432")
            with conn:
                #qry_c = """SELECT * from "01"."SECCION_INE";"""
                #qry_c = "SELECT * from bged.numeros_exteriores where id = %s;" 
                qry_c = "SELECT municipio, seccion from bged.seccion where municipio = %s order by seccion asc;"
                #data_c = (self.campo01, )
                #data_c = (str(result[0]), )
                data_c = (numeroMunicipio, )
                with conn.cursor() as curs:
                    #self.iface.messageBar().pushMessage("Mensaje", "Se llego al codigo para crear la consulta")
                    curs.execute(qry_c, data_c)
                    #curs.execute(qry_c)
                    #self.iface.messageBar().pushMessage("Mensaje", "Se ejecuto la consulta")
                    #result = curs.fetchone()
                        #if result == None:
                        #QMessageBox.information(self.iface.mainWindow(), "No hay extracción","No hay elementos que importar...")
                        #return
                        #else:
                    
                    rows = curs.fetchall() #one row
                    for row in rows:
                        #self.iface.messageBar().pushMessage("Datos seccion row  ", str(row[1]))
                        #mun_num = str(row[0]) + " : " + row[1]
                        sec_num = str(row[1])
                        self.dockwidget.cveSeccion.addItem(sec_num)

                curs.close()    
                #self.iface.messageBar().pushMessage("Mensaje", "Se logro poblar el combo de secciones")   
            conn.close()



            return None

        except:
            
            QMessageBox.warning(self.iface.mainWindow(), "Aviso", "No se logró obtener los datos de las secciones de acuerdo con el municipio seleccionado, revise sus credenciales o su conexión a internet.")
            #print ("I am unable to connect to the database")
            #self.dockwidget.txtUsuario.setText("")    
            #self.dockwidget.txtClave.setText("")
            return None


        #self.comboBox.currentIndexChanged.connect(self.on_combobox_changed, self.comboBox.currentIndex())

    
    def btnObtenerArea_accion(self):
    
        #prueba
        #QMessageBox.warning(self.iface.mainWindow(), "Mensaje","Se ejecuto el comando del boton.")

        #Ok Desde la funcion de conectar, poblar combo con municipios (usar codigo del boton identificar 10 metros o 20 metros para la carga)
        #Ok Posteriormente al seleccionar el municipio deseado del primer combo, se cargan las secciones correspondientes en el 2do combo
        #Al dar clic en boton Obtener area de trabajo la seccion del 2do combo se toma como dato y se ejecuta una funcion para cargar dicha capa
        #Se ejecuta un zoom sobre la seccion elegida para obtener un acercamiento y se elabora un query con un radio de 10km sobre las 3 capas restantes
        #Se cargan las 3 capas provenientes del query con el fin de disminuir la cantidad de informacion para ser visualizada
        #Se colocan las etiquetas de las 4 capas y se ajustan algunas propiedades que puedan ser necesarias.
        #Se desactivan visualmente todas las capas a excepcion de la de numeros exteriores, en este paso se permite al usuario elegir tramo del num ext.
        #Se procede al tab de edicion para mostrar la informacion del tramo seleccionado

        try:

            #Se configura la barra de progreso y se fija el valor inicial en 0 para comenzar el proceso
            prog = QProgressDialog('Cargando capas. Un momento, por favor.', '', 0, 100)
            prog.setWindowModality(Qt.WindowModal)
            prog.setCancelButton(None)
            time.sleep(1)

            #Borrar capas si hubo cambio de entidad
            municipioActual = str(self.dockwidget.cveMunicipio.currentText().split(" :",1)[0])
            #self.iface.messageBar().pushMessage("Mensaje", "ultimo mun y actual = : " + self.ultimoMunicipio + " " + municipioActual)

            #self.iface.messageBar().pushMessage("Mensaje", "Se remueven layers " + self.dockwidget.cveEntidad.currentText() + " " + self.ultimaEntidad)
            if self.dockwidget.cveEntidad.currentText() != self.ultimaEntidad  or self.ultimoMunicipio != municipioActual:
                #borrar capas
                # Get list of vector layers
                layers = list(QgsProject.instance().mapLayers().values())
                # Check there is at least one vector layer. Selecting within the same layer is fine.
                #vlayer_count = 0
                for layer in layers:
                    if layer.type() == QgsMapLayer.VectorLayer:
                        QgsProject.instance().removeMapLayer(layer)
                        #self.iface.messageBar().pushMessage("Mensaje", "Se remueven layers")
                        #vlayer_count = vlayer_count + 1
                    #if layer.name() == "SeccionUnica":

                self.ultimaEntidad = self.dockwidget.cveEntidad.currentText()
                self.ultimoMunicipio = municipioActual

            
            # Get list of vector layers
            layers = list(QgsProject.instance().mapLayers().values())
            # Check there is at least one vector layer. Selecting within the same layer is fine.
            vlayer_count = 0
            for layer in layers:
                if layer.type() == QgsMapLayer.VectorLayer:
                    vlayer_count = vlayer_count + 1
                if layer.name() == "SeccionUnica":
                    QgsProject.instance().removeMapLayer(layer)
                    #QtTest.QTest.qWait(100)

            #root = QgsProject.instance().layerTreeRoot()

            #self.iface.messageBar().pushMessage("Mensaje", "Numero de capas: " + str(vlayer_count))


            numeroSeccion = str(self.dockwidget.cveSeccion.currentText())
            numeroMunicipio = str(self.dockwidget.cveMunicipio.currentText().split(" :",1)[0])

            #self.iface.messageBar().pushMessage("Mensaje", "Seccion: " + numeroSeccion)
            #self.iface.messageBar().pushMessage("Mensaje", "Municipio: " + numeroMunicipio)

            usr = self.dockwidget.txtUsuario.text()
            pwd = self.dockwidget.txtClave.text()
            
            uri = QgsDataSourceUri()
            # set host name, port, database name, username and password
            uri.setConnection(self.servidor, "5432", self.baseDatos, usr, pwd)
            # set database schema, table name, geometry column and optionally
            # subset (WHERE clause)



            #Capa auxiliar para reconocer la seccion a trabajar
            QtTest.QTest.qWait(100)
            #Consulta de seccion mediante seccion (una seccion para emular zoom en ella)
            uri.setDataSource("bged", "seccion", "geom", "seccion=" + numeroSeccion)
            vlayer1SEC = QgsVectorLayer(uri.uri(False), "SeccionUnica", "postgres")
            #vlayer1SEC.setLayerTransparency(50)
            QgsProject.instance().addMapLayer(vlayer1SEC)
            #QgsMapLayerRegistry.instance().addMapLayer(vlayerNE)

            QtTest.QTest.qWait(700)

            #funciona para el zoom
            iface.setActiveLayer(vlayer1SEC)
            iface.zoomToActiveLayer()

            #	232	56	69
            QtTest.QTest.qWait(200)

            #layer_base = iface.activeLayer()
            #mySymbol1 = QgsFillSymbol.createSimple({'color':'#E83845', 'color_border':'#E83845', 'width_border':'0.3', 'style':'no'})
            #myRenderer = vlayer1SEC.renderer()
            #myRenderer.setSymbol(mySymbol1)
            #vlayer1SEC.triggerRepaint()
            #QtTest.QTest.qWait(100)

            vlayer1SEC.setOpacity(0.3)

            mySymbol1 = QgsFillSymbol.createSimple({'color':'red', 'color_border':'red', 'width_border':'0.3', 'style':'solid'})
            myRenderer = vlayer1SEC.renderer()
            myRenderer.setSymbol(mySymbol1)

            #Muestra el 20% de avance
            prog.setValue(20)

            vlayer1SEC.triggerRepaint()
            QtTest.QTest.qWait(100)
            #se elimina capa de la unica seccion solo se agrego para emular zoom, ya no se elimina se usa como transparencia
            #QgsProject.instance().removeMapLayer(vlayer1SEC)
            QtTest.QTest.qWait(200)

            #Estas capas se cargan una sola vez, Seccion, Manzana, Vialidad, Num Ext
            if vlayer_count == 0:
                #for layer in layers:
                #vl = iface.activeLayer()
                #QtTest.QTest.qWait(100)
                #capaactiva = vl.name()
                #self.iface.messageBar().pushMessage("Mensaje", "capa removida: " + capaactiva)
                #QgsProject.instance().removeMapLayer(capaactiva)
                #QtTest.QTest.qWait(500)


                #Consulta de seccion mediante municipio/seccion
                uri.setDataSource("bged", "seccion", "geom", "municipio=" + numeroMunicipio)
                #uri.setDataSource("bged", "seccion", "geom", "seccion=" + numeroSeccion)
                #uri.setDataSource("bged", "seccion", "geom")
                vlayerSEC = QgsVectorLayer(uri.uri(False), "Seccion", "postgres")
                QgsProject.instance().addMapLayer(vlayerSEC)
                #self.iface.messageBar().pushMessage("Mensaje", "Se hizo consulta en Seccion con mun = : " + numeroMunicipio)

                #Se configura el formato de las etiquetas
                SE_layer = QgsPalLayerSettings()
                textFormat = QgsTextFormat()
                textFormat.setColor(Qt.darkRed)
                textFormat.setSize(15)
                textFormat.buffer().setEnabled(True)
                textFormat.buffer().setSize(0.7)
                textFormat.buffer().setColor(QColor('#FFFFFF'))
                SE_layer.setFormat(textFormat)
                SE_layer.fieldName = '\'Sección \n\' || lpad(to_string("seccion"),4,\'0\')' #Sección a cuatro digitos, del tipo 0000
                SE_layer.isExpression = True
                SE_layer.enabled = True
                SE_layer.placement = QgsPalLayerSettings.OverPoint
                SElabels = QgsVectorLayerSimpleLabeling(SE_layer)
                SElabels.drawLabels = True
                vlayerSEC.setLabeling(SElabels)
                vlayerSEC.setLabelsEnabled(True)
                vlayerSEC.setCustomProperty("labeling/drawLabels",  "True") 
                vlayerSEC.triggerRepaint()
                QtTest.QTest.qWait(200)


                #layer_base = iface.activeLayer()
                mySymbol1 = QgsFillSymbol.createSimple({'color':'red', 'color_border':'red', 'width_border':'0.4', 'style':'no'})
                myRenderer = vlayerSEC.renderer()
                myRenderer.setSymbol(mySymbol1)
                vlayerSEC.triggerRepaint()
                QtTest.QTest.qWait(1000)
                #E83845
                
                #Muestra el 40% de avance
                prog.setValue(40)

                #Cargar capas
                #uri.setDataSource("bged", "manzana", "geom")
                #qry_c = 'select * from bged.manzana mza, bged.municipio mun where mun.municipio =  \'numeroMunicipio\' and st_intersects(mun.geom, mza.geom)'
                #qry_c =  'SELECT * FROM (SELECT * FROM bged.manzana mza, bged.municipio mun where mun.municipio = {self.dockwidget.cveSeccion.currentText()} and st_intersects(mun.geom, mza.geom)) AS "subQuery_0" LIMIT 1'
                qry_c =  'SELECT * FROM bged.manzana mza, bged.municipio mun where mun.municipio={}.format(numeroMunicipio) and st_intersects(mun.geom, mza.geom)'
                #qry_c = ("SELECT * FROM (select * from bged.manzana);") AS "subQuery_0" LIMIT 1
                #myvalue=1000
                #uri.setDataSource("bged", "manzana", "geom", "seccion={}".format(numeroSeccion))
                #uri.setDataSource("bged", "manzana", "geom")
                uri.setDataSource("bged", "manzana", "geom", "municipio=" + numeroMunicipio)
                #uri.setDataSource('', f'({qry_c})', 'geom', '', '')
                vlayerM = QgsVectorLayer(uri.uri(False), "Manzana", "postgres")
                
                QgsProject.instance().addMapLayer(vlayerM)

                MZ_layer = QgsPalLayerSettings()
                textFormat = QgsTextFormat()
                textFormat.setColor(QColor('#464646')) 
                textFormat.setSize(11) 
                textFormat.buffer().setEnabled(True)
                textFormat.buffer().setColor(QColor('#FFFFFF'))
                textFormat.buffer().setSize(0.7)
                MZ_layer.setFormat(textFormat)
                MZ_layer.fieldName = '\'Mz \n\' || "id"'
                MZ_layer.isExpression = True
                MZ_layer.enabled = True
                MZ_layer.placement = QgsPalLayerSettings.AroundPoint
                MZlabels = QgsVectorLayerSimpleLabeling(MZ_layer)
                MZlabels.drawLabels = True
                vlayerM.setLabeling(MZlabels)
                vlayerM.setLabelsEnabled(True)
                vlayerM.setCustomProperty("labeling/drawLabels",  "True")
                vlayerM.triggerRepaint()
                QtTest.QTest.qWait(200)

                #vlayerM.setCustomProperty("labeling/drawLabels",  "True")

                #vlayerM.renderer().symbol().symbolLayer(0).setShape(QgsSimpleMarkerSymbolLayerBase.Star)
                #QgsSimpleLineSymbolLayerV2
                #vlayerM.triggerRepaint()

                #layer_base = iface.activeLayer()
                mySymbol1 = QgsFillSymbol.createSimple({'color':'#289E26', 'color_border':'#237E21', 'width_border':'0.2', 'style':'dense6'})
                myRenderer = vlayerM.renderer()
                myRenderer.setSymbol(mySymbol1)
                vlayerM.triggerRepaint()
                QtTest.QTest.qWait(1500)
                #E83845            prog.setValue(20)

                #Muestra el 60% de avance
                prog.setValue(60) 

                #symbol = QgsSymbolV2.defaultSymbol(vlayerM.geometryType())
                #renderer = QgsSingleSymbolRendererV2(symbol)

                uri.setDataSource("bged", "vialidad", "geom")
                vlayerV = QgsVectorLayer(uri.uri(False), "Vialidad", "postgres")
                QgsProject.instance().addMapLayer(vlayerV)

                V_layer = QgsPalLayerSettings()
                textFormat = QgsTextFormat()
                textFormat.setColor(QColor('#22243B')) 
                textFormat.setSize(11) 
                textFormat.buffer().setEnabled(True)
                textFormat.buffer().setColor(QColor('#FFFFFF'))
                textFormat.buffer().setSize(0.7)
                V_layer.setFormat(textFormat)
                V_layer.fieldName = '"id" || \' \' || title("nombre")'
                V_layer.isExpression = True
                V_layer.enabled = True
                V_layer.placement = QgsPalLayerSettings.Curved
                Vlabels = QgsVectorLayerSimpleLabeling(V_layer)
                Vlabels.drawLabels = True
                vlayerV.setLabeling(Vlabels)
                vlayerV.setLabelsEnabled(True)
                vlayerV.setCustomProperty("labeling/drawLabels",  "True")
                vlayerV.triggerRepaint()
                QtTest.QTest.qWait(500)

                #layer_base = iface.activeLayer()
                #mySymbol1 = QgsFillSymbol.createSimple({'color':'#289e26', 'color_border':'#289e26', 'width_border':'0.3', 'style':'no'})
                #myRenderer = layer_base.renderer()
                #myRenderer.setSymbol(mySymbol1)
                #layer_base.triggerRepaint()
                #QtTest.QTest.qWait(100)

                #layer = iface.activeLayer()
                renderer = vlayerV.renderer()
                symbol1 = QgsLineSymbol.createSimple({'color': 'brown','width':'.3'})
                renderer.setSymbol(symbol1) 
                vlayerV.triggerRepaint()
                #iface.legendInterface().refreshLayerSymbology(layer)
                #iface.mapCanvas().refresh()
                QtTest.QTest.qWait(3000)

                #Muestra el 80% de avance
                prog.setValue(80)

                #Consulta de numeros exteriores con campos nulos
                #uri.setDataSource("bged", "numeros_exteriores", "geom", "manzana is not null")
                uri.setDataSource("bged", "numeros_exteriores", "geom")
                vlayerNE = QgsVectorLayer(uri.uri(False), "NumerosExteriores", "postgres")
                QgsProject.instance().addMapLayer(vlayerNE)
                QtTest.QTest.qWait(100)

                NE_layer = QgsPalLayerSettings()
                NE_layer.fieldName = 'id'
                #NE_layer.fieldName = '\'Id NumExt \' || id'
                NE_layer.enabled = True
                NE_layer.placement = QgsPalLayerSettings.Free
                NElabels = QgsVectorLayerSimpleLabeling(NE_layer)
                NElabels.drawLabels = True
                vlayerNE.setLabeling(NElabels)
                vlayerNE.setLabelsEnabled(True)
                vlayerNE.setCustomProperty("labeling/drawLabels",  "True")
                vlayerNE.triggerRepaint()
                QtTest.QTest.qWait(200)



                #layer_base = iface.activeLayer()
                #mySymbol1 = QgsFillSymbol.createSimple({'color':'#289e26', 'color_border':'#289e26', 'width_border':'0.3', 'style':'no'})
                #myRenderer = layer_base.renderer()
                #myRenderer.setSymbol(mySymbol1)
                #layer_base.triggerRepaint()
                #QtTest.QTest.qWait(100)

                #layer = iface.activeLayer()
                renderer = vlayerNE.renderer()
                symbol1 = QgsLineSymbol.createSimple({'color':'#005F00', 'width':'0.3', 'line_style':'dash'})
                renderer.setSymbol(symbol1) 
                vlayerNE.triggerRepaint()
                #iface.QgsLegendInterface().refreshLayerSymbology(layer)
                #iface.mapCanvas().refresh()
                QtTest.QTest.qWait(3000)

                self.ultimoMunicipio = municipioActual

            
            #Borrar campos de texto en edicion simple
            self.dockwidget.textEdit.setText("")
            self.dockwidget.idManzana.setText("")
            self.dockwidget.idManzana_original.setText("")
            self.dockwidget.idVialidad_original.setText("")  

            #Se ajusta el valor de progreso de 100% para mostrar el fin del proceso
            prog.setValue(100) 
            QMessageBox.information(self.iface.mainWindow(), "Aviso", "Listo, se cargaron las capas del área de trabajo exitosamente.")

        except:

            QMessageBox.warning(self.iface.mainWindow(), "Aviso", "No se logró cargar las capas adecuadamente, revise su conexión a internet.")

            return None
    
    def btnRecomendaciones_accion(self):
        QMessageBox.information(self.iface.mainWindow(), "Aviso", "Para visualizar adecuadamente este Plugin en su pantalla se recomienda utilzar cualquiera de las siguientes resoluciones de pantalla:\n \n-1920 x 1080 \n-2048 x 1152 \n-2560 x 1600.")
        return

        
    def btnMostrar_accion(self):
    
        #pass
        #Probando funcion
        #self.dockwidget.txtClave.setText("Adios")
        self.campo01 = ""

        #limpiar datos en combo idVialidad e idManzana
        self.dockwidget.idVialidad.clear()
        self.dockwidget.idManzana.setText("")
        
        # Get list of vector layers
        layers = list(QgsProject.instance().mapLayers().values())
        # Check there is at least one vector layer. Selecting within the same layer is fine.
        vlayer_count = 0
        for layer in layers:
            if layer.type() == QgsMapLayer.VectorLayer:
                vlayer_count = vlayer_count + 1


        #layer = QgsProject.instance().mapLayersByName('numeros_exteriores')[0].id()
        #layer.selectByExpression(f"{attribute_name} ='{OSnaam}'")

        if vlayer_count > 0:
        
            #layer = QgsProject.instance().mapLayersByName('numeros_exteriores')

            #Obtener Datos, modificar para activar el layer de numero exteriores, Importante!!! se evita error de seleccion de tramo
            vl = iface.activeLayer()
            capaactiva = vl.name()

            if capaactiva != "NumerosExteriores":
                QMessageBox.warning(self.iface.mainWindow(), "Alerta", "Por favor seleccione la capa NumerosExteriores, la capa actual es "  + capaactiva)
                return

            # get the list of selected ids 
            ids = vl.selectedFeatureIds()
            
            #QMessageBox.warning(self.iface.mainWindow(), "Totales",str(len(ids)))
            
            if len(ids) == 1:
                # create the request with the selected ids
                request = QgsFeatureRequest()
                request.setFilterFids(ids)

                fields = ['id']

                features = vl.getFeatures(request)
                for feature in features:
                    attrs = [feature[field] for field in fields]
                
                self.campo01 = str(attrs[0])
                
                #QMessageBox.warning(self.iface.mainWindow(), "ID",campo01)
                
                #self.dockwidget.labelOrigen.setText("ID:" + campo01 + "\n\r" + result01 + "\n\r" + result02 + "\n\r" + result03 + "\n\r" + result04  + "\n\r" + result05 + "\n\r" + result06)
                
                # # show the dialog
                # self.dockwidget.show()
                # # Run the dialog event loop
                # result = self.dockwidget.exec_()
                # # See if OK was pressed
                # if result:
                    # # Grabar a Postgres
                    # conn = psycopg2.connect(dbname=dbs_, user=user_, password=pass_, host=host_)
                    # cursor = conn.cursor()
                    # cursor2 = conn.cursor()
                    # qry = "UPDATE nueva_cartografia_ine.limite_localidad_inegi set entidad = %s, municipio = %s, localidad = %s, nombre = %s, tipo = %s, cabecera = %s where id = %s;"
                    # data = (result01,result02,result03,result04,result05,result06,campo01)
                    # cursor.execute(qry,data)
                    # qry2 = "UPDATE public.trasladar_captura set entidad = %s,municipio = %s,localidad = %s,nombre = %s,tipo = %s,cabecera = %s,recuperado = %s where mac = %s;"
                    # data2 = (None,None,None,None,None,None,None,iden_)
                    # cursor2.execute(qry2,data2)  
                    # conn.commit()
                    # cursor.close()
                    # cursor2.close()
                    # conn.close()                   
                    # Confirmar
                    #QMessageBox.information(self.iface.mainWindow(), "Captura","Captura Actualizada...")
            elif len(ids) == 0: 
                QMessageBox.warning(self.iface.mainWindow(), "Verifique","No seleccionó ningún elemento.")	
            else:
                QMessageBox.warning(self.iface.mainWindow(), "Verifique","Debe seleccionar un solo elemento.")	
        else:
            QMessageBox.warning(self.iface.mainWindow(), "Verifique","No hay capas vectoriales agregadas.")		
        
        
        usr = self.dockwidget.txtUsuario.text()
        pwd = self.dockwidget.txtClave.text()
        
        #localhost
        #conn = psycopg2.connect(database="ECEG", user=usr, password=pwd, host="localhost", port="5432")
        #remote Samge bged 
        conn = psycopg2.connect(database=self.baseDatos, user=usr, password=pwd, host=self.servidor, port="5432")
        
        #conn = psycopg2.connect("database='ECEG' user='postgres' password='svm' host='localhost' port='5432'")
        #conn = psycopg2.connect("database='ECEG' user=usr password=pwd host='localhost' port='5432'")

        #cur.execute("""SELECT datname from pg_database""")
        #cur.execute("""SELECT * from bar""")

        #cursor = conn.cursor()
        
        #"Select '"+get_userid+"' in (select userid from public.qgis_user) and '"+get_userpswrd+"' = (select user_password from public.qgis_user where userid='"+get_userid+"') ;")
        
        
        #query = "SELECT * FROM 01.'SECCION_INE WHERE'"
        #schema_name."table_name"
        #query = 'Select * FROM {0}. {1}'.format("01","SECCION_INE")
        #query = cursor.execute('Select * FROM {0}. {1}'.format("01","SECCION_INE"))
        #query = "SELECT * from 01.SECCION_INE;" #where mac = %s and recuperado = '1';"
        
        #self.iface.messageBar().pushMessage("Mensaje", "Se llego al codigo para crear la consulta")
        
        #cursor.execute(query)
        #"""select * from dl."products";"""
        #cursor.execute("""select * from 01.SECCION_INE;""")
        #cursor.fetchone()  #one row
        
        #self.iface.messageBar().pushMessage("Mensaje", "Se ejecuto la consulta")
        
        
        # results = cursor.fetchall() #all rows
        # for result in results:
            # self.iface.messageBar().pushMessage("Datos:", "result")
            # #print (result)
        # cursor.close()
        # conn.close()
        # self.iface.messageBar().pushMessage("Mensaje", "Se ingreso a la Base")
            
            
            
        with conn:
            #qry_c = """SELECT * from "01"."SECCION_INE";"""
            #qry_c = "SELECT * from bged.numeros_exteriores where id = %s;"
            qry_c = "SELECT geom, tramo, manzana, vialidad, numext, valida from bged.numeros_exteriores where id = %s;"
            data_c = (self.campo01, )
            with conn.cursor() as curs:
                #self.iface.messageBar().pushMessage("Mensaje", "Se llego al codigo para crear la consulta")
                curs.execute(qry_c, data_c)
                #curs.execute(qry_c)
                #self.iface.messageBar().pushMessage("Mensaje", "Se ejecuto la consulta")
                #result = curs.fetchone()
                #if result == None:
                    #QMessageBox.information(self.iface.mainWindow(), "No hay extracción","No hay elementos que importar...")
                    #return
                #else:
                
                results = curs.fetchone() #one row
                #for result in results:
                    #self.iface.messageBar().pushMessage("Datos  ", result)
                
                #Entidades 01,09
                result01 = results[0]   #geom           tramo
                result02 = results[1]   #tramo          manzana
                result03 = results[2]   #idManzana      vialidad
                result04 = results[3]   #idVialidad     numext
                result05 = results[4]   #idNumExt       valida
                result06 = results[5]   #valida         pro
                #pro                                    geom
                #control                                control
                #id                                     id

                #Entidad 28
                #result01 = results[6]   #geom           tramo
                #result02 = results[0]   #tramo          manzana
                #result03 = results[1]   #idManzana      vialidad
                #result04 = results[2]   #idVialidad     numext
                #result05 = results[3]   #idNumExt       valida
                #result06 = results[4]   #valida         pro
                #pro                                     geom
                #control                                 control
                #id                                      id
                    
                #self.iface.messageBar().pushMessage("Datos  ", result05)
                self.dockwidget.textEdit.setText(result05)

                #self.iface.messageBar().pushMessage("Datos  ", result03)
                self.dockwidget.idManzana_original.setText(str(result03))
                #self.dockwidget.idManzana.setText(str(result03))
                
                #self.iface.messageBar().pushMessage("Datos  ", result04)
                #self.dockwidget.idVialidad.setCurrentText(str(result04))
                self.dockwidget.idVialidad_original.setText(str(result04))
                
                #fontComboBox
                
                #self.dockwidget.textEdit.setText(result03)
                #self.dockwidget.txtUsuario_2.setText(result03)
                #self.dockwidget.spinBox.setText(result04)
                #QMessageBox.information(self.iface.mainWindow(), "Ya no hay extraccion","No hay mas elementos que importar...")
        conn.close()
            
    def btnSugerir_accion(self):

        self.campo01 = ""

        layers = list(QgsProject.instance().mapLayers().values())

        vlayer_count = 0
        for layer in layers:
            if layer.type() == QgsMapLayer.VectorLayer:
                vlayer_count = vlayer_count + 1


        if vlayer_count > 0:
        
            vl = iface.activeLayer()
            capaactiva = vl.name()

            if capaactiva != "NumerosExteriores":
                QMessageBox.warning(self.iface.mainWindow(), "Alerta", "Por favor seleccione la capa NumerosExteriores, la capa actual es "  + capaactiva)
                return

            ids = vl.selectedFeatureIds()
 
            if len(ids) == 1:
   
                request = QgsFeatureRequest()
                request.setFilterFids(ids)

                fields = ['id']

                features = vl.getFeatures(request)
                for feature in features:
                    attrs = [feature[field] for field in fields]
                
                self.campo01 = str(attrs[0])
                

            elif len(ids) == 0: 
                QMessageBox.warning(self.iface.mainWindow(), "Verifique","No seleccionó ningún elemento.")	
            else:
                QMessageBox.warning(self.iface.mainWindow(), "Verifique","Debe seleccionar un solo elemento.")	
        else:
            QMessageBox.warning(self.iface.mainWindow(), "Verifique","No hay capas vectoriales agregadas.")		
 
        usr = self.dockwidget.txtUsuario.text()
        pwd = self.dockwidget.txtClave.text()

        conn = psycopg2.connect(database=self.baseDatos, user=usr, password=pwd, host=self.servidor, port="5432") 
        #Configura la barra de progreso 
        prog = QProgressDialog('Buscando Id de Manzana. Un momento, por favor.', '', 0, 100)
        prog.setWindowModality(Qt.WindowModal)
        prog.setCancelButton(None)
        time.sleep(2)
        prog.setValue(25)
        #Se conecta a la BD para obtener el id del registro seleccionado de la capa de números exteriores
        with conn:

            qry_c = "SELECT geom, id from bged.numeros_exteriores where id = %s;"
            data_c = (self.campo01, )
            with conn.cursor() as curs:

                prog.setValue(50)
                curs.execute(qry_c, data_c)
                results = curs.fetchone() #one row
                result01 = results[0]   #geom           
                result02 = results[1]   #id

        with conn:

            #Se conecta a ala BD para obtener el id de la manzana que toca o está a 1m del número exterior selccionado
            qry_c = "SELECT a.id as id_mza FROM bged.manzana as a, bged.numeros_exteriores as b WHERE b.id = {0} AND ST_Intersects(ST_Buffer(a.geom,1),b.geom) = 'true';".format(result02)
            data_c = (self.campo01, )
            with conn.cursor() as curs:

                prog.setValue(75)
                curs.execute(qry_c, data_c)
                results = curs.fetchone() #one row
                idmzasug = results[0]   #id           id manzana sugerido

                if (idmzasug is None or idmzasug == ''):
                    QMessageBox.warning(self.iface.mainWindow(), "Aviso","No se encontró ningún id de manzana.")
                      
            self.dockwidget.idManzana.setText(str(idmzasug))
            
            prog.setValue(100)
        #Ajusta el valor al 100% para concluir la barra de progreso
        conn.close()
        
    
    def tmaxFont(self):
        #self.dockwidget.textEdit.setFontPointSize(32);
        #self.dockwidget.textEdit.setFont(QFont('Arial', 30))
        
        f = self.dockwidget.textEdit.font()
        #f.setPointSize(27) # sets the size to 27
        
        #tEditSize = int(self.dockwidget.self.dockwidget.textEdit.fontPointSize())
        #f.setPointSize( int(self.dockwidget.self.dockwidget.textEdit.fontPointSize()) + 2)
        #f.setPointSize( int(self.dockwidget.textEdit.fontPointSize()) + 2)
        f.setPointSize(18)
        # sets the size to 27
        
        self.dockwidget.textEdit.setFont(f)
        
        #tamaf = self.dockwidget.textEdit.fontPointSize()
        #stringSize = str(tamaf)

        #self.iface.messageBar().pushMessage("Mensaje", str(self.dockwidget.textEdit.fontPointSize()))

        #QtTest.QTest.qWait(1800)

        #tamaf = self.dockwidget.textEdit.fontPointSize()
        #stringSize = str(tamaf)


        #self.iface.messageBar().pushMessage("Mensaje", stringSize)
        
        #QtTest.QTest.qWait(50)
        #tamaf = self.dockwidget.textEdit.fontPointSize()
        
        #tamaf = self.dockwidget.textEdit.fontPointSize()
        
        #var tamaf = f.fontPointSize()
        #self.dockwidget.idVialidad.setCurrentText(str(tamaf))

        
    def tmedFont(self):
        #self.dockwidget.textEdit.setFontPointSize(12);

        f = self.dockwidget.textEdit.font()
        #f.setPointSize(27) # sets the size to 27
        
        #tEditSize = int(self.dockwidget.self.dockwidget.textEdit.fontPointSize())
        #f.setPointSize( int(self.dockwidget.self.dockwidget.textEdit.fontPointSize()) + 2)
        #f.setPointSize( int(self.dockwidget.textEdit.fontPointSize()) + 2)
        f.setPointSize(14)
        # sets the size to 27
        
        self.dockwidget.textEdit.setFont(f)


        
    def tminFont(self):
        #self.dockwidget.textEdit.setFontPointSize(12);
        
        f = self.dockwidget.textEdit.font()
        #f.setPointSize(27) # sets the size to 27
        
        #tEditSize = int(self.dockwidget.self.dockwidget.textEdit.fontPointSize())
        #f.setPointSize( int(self.dockwidget.self.dockwidget.textEdit.fontPointSize()) + 2)
        #f.setPointSize( int(self.dockwidget.textEdit.fontPointSize()) + 2)
        f.setPointSize(12)
        # sets the size to 27
        
        self.dockwidget.textEdit.setFont(f)

    
    
    def btnInvertir(self):
    
        cadena = self.dockwidget.textEdit.toPlainText()
        invertida = ','.join((cadena.split(",")[::-1]))
        #invertida = str(''.join([cadena.split(",")[::-1]]))
        #placeholderText()
        #invertida = cadena[::-1] 
        self.dockwidget.textEdit.setText(invertida)
        
        #btnInvertir
      
    def btnGuardar(self):
    
        #pass
 
        try:

            usr = self.dockwidget.txtUsuario.text()
            pwd = self.dockwidget.txtClave.text()
        
            #localhost
            #conn = psycopg2.connect(database="ECEG", user=usr, password=pwd, host="localhost", port="5432")
            #remote Samge bged 
            conn = psycopg2.connect(database=self.baseDatos, user=usr, password=pwd, host=self.servidor, port="5432")
    
            #Grabar a Postgres
            #conn = psycopg2.connect(database="bged01_desarrollo", user=usr, password=pwd, host="172.19.122.145", port="5432")
            #conn = psycopg2.connect(dbname=dbs_, user=user_, password=pass_, host=host_)
            cursor = conn.cursor()
            #cursor2 = conn.cursor()
        
            #self.iface.messageBar().pushMessage("Mensaje id numExt update guardar", self.campo01)
        
            qry = "UPDATE bged.numeros_exteriores set manzana = %s, vialidad = %s, numext = %s where id = %s;"
        
        
            #Ejemplo de prueba        
            #my_string = "hello\nworld\n"
            #new_string = ''.join(my_string.split('\n'))

            Id_manzana_actual = self.dockwidget.idManzana_original.text()
            Id_vialidad_actual = self.dockwidget.idVialidad_original.text()
            numeroExterior = self.dockwidget.textEdit.toPlainText()

            #Mostrar variables de datos actuales del numero exterior
            #QMessageBox.warning(self.iface.mainWindow(), "Aviso","id manzana: " + Id_manzana_actual)
            #QMessageBox.warning(self.iface.mainWindow(), "Aviso","id vialidad: " + Id_vialidad_actual)
            #QMessageBox.warning(self.iface.mainWindow(), "Aviso","Numero Ext: " + numeroExterior)

            IdNumeroManzana = self.dockwidget.idManzana.text()
            if ' : ' in self.dockwidget.idVialidad.currentText():
                IdNumeroVialidad = str(self.dockwidget.idVialidad.currentText().split(" :",1)[0])
            else:
                IdNumeroVialidad = self.dockwidget.idVialidad.currentText()
           
            

            #original
            #data = (self.dockwidget.idManzana.text(),self.dockwidget.idVialidad.currentText(),self.dockwidget.textEdit.toPlainText(),self.campo01)
            #variable numeroVialidad con tratamineto a cadena vialidad y nombre
            #data = (self.dockwidget.idManzana.text(),numeroVialidad,self.dockwidget.textEdit.toPlainText(),self.campo01)
        
        

            #if self.dockwidget.idManzana.text() != null:
            #Parece que no pela el tipo none
            if IdNumeroManzana == "":
                if (Id_manzana_actual and not Id_manzana_actual.isspace()) and not Id_manzana_actual == "None":
                    # the string is non-empty
                    QMessageBox.information(self.iface.mainWindow(), "Aviso","No se actualizó el dato de Id manzana corregido, se conserva el actual: " + Id_manzana_actual)
                    IdNumeroManzana = Id_manzana_actual
                else:
                    # the string is empty
                    QMessageBox.warning(self.iface.mainWindow(), "Aviso","Debe ingresar el dato Id manzana corregido para guardar los cambios.")
                    return

            if IdNumeroVialidad == "":
                if (Id_vialidad_actual and not Id_vialidad_actual.isspace()) and not Id_vialidad_actual == "None":
                    # the string is non-empty
                    QMessageBox.information(self.iface.mainWindow(), "Aviso","No se actualizó el dato de Identificador de Vialidad más cercano, se conserva el actual: " + Id_vialidad_actual)
                    IdNumeroVialidad = Id_vialidad_actual
                else:
                    # the string is empty
                    QMessageBox.warning(self.iface.mainWindow(), "Aviso","Debe ingresar el dato de Identificador de Vialidad más cercano para guardar los cambios.")
                    return
            

            if numeroExterior == "" or numeroExterior == "None":
                # the string is empty
                QMessageBox.warning(self.iface.mainWindow(), "Aviso","Debe ingresar el dato de Numero Exterior para guardar los cambios.")
                return



            #IdNumeroManzana = ''.join(IdNumeroManzana.split('\n'))
            #IdNumeroManzana = ''.join(IdNumeroManzana.split('\r'))
            IdNumeroManzana = IdNumeroManzana.strip()

            #IdNumeroVialidad = ''.join(IdNumeroVialidad.split('\n'))
            #IdNumeroVialidad = ''.join(IdNumeroVialidad.split('\r'))
            #IdNumeroVialidad = ''.join(IdNumeroVialidad.split(' '))
            IdNumeroVialidad = IdNumeroVialidad.strip()

            #numeroExterior = ''.join(numeroExterior.split('\n'))
            #numeroExterior = ''.join(numeroExterior.split('\r'))
            #numeroExterior = ''.join(numeroExterior.split(' '))
            numeroExterior = numeroExterior.strip()

            #Mostrar variables de datos que se van a almacenar del numero exterior
            #QMessageBox.warning(self.iface.mainWindow(), "Aviso","id manzana: ." + IdNumeroManzana + ".")
            #QMessageBox.warning(self.iface.mainWindow(), "Aviso","id vialidad: ." + IdNumeroVialidad + ".")
            #QMessageBox.warning(self.iface.mainWindow(), "Aviso","Numero Ext: ." + numeroExterior + ".")



            data = (IdNumeroManzana,IdNumeroVialidad,numeroExterior,self.campo01)
        
        
            cursor.execute(qry,data)
            #qry2 = "UPDATE public.trasladar_captura set entidad = %s,municipio = %s,localidad = %s,nombre = %s,tipo = %s,cabecera = %s,recuperado = %s where mac = %s;"
            #data2 = (None,None,None,None,None,None,None,iden_)
            #cursor2.execute(qry2,data2)  
            conn.commit()
            cursor.close()
            #cursor2.close()
            conn.close()                   
            #Confirmar
            #QMessageBox.information(self.iface.mainWindow(), "Captura","Captura Actualizada...")

            QMessageBox.information(self.iface.mainWindow(), "Aviso","Se guardaron los cambios.")
        
            #cadena = self.dockwidget.textEdit.toPlainText()
            #invertida = ','.join((cadena.split(",")[::-1]))
        
            #invertida = str(''.join([cadena.split(",")[::-1]]))
            #placeholderText()
            #invertida = cadena[::-1] 
        
            #self.dockwidget.textEdit.setText(invertida)      
        
            #btnGuardar

        except:

            QMessageBox.warning(self.iface.mainWindow(), "Aviso", "No se logró guardar la información, revise los datos capturados, sus credenciales o su conexión a internet.")
            return None

        
    def btnCrearCadena(self):
        
        intervalos = ""
        puntoInicio = 0
        intervaloAlfa = ""
        #btnCrearCadena
        if (self.dockwidget.txtRinicial.text().isnumeric() == True and self.dockwidget.txtRfinal.text().isnumeric() == True and self.dockwidget.txtRIntervalo.text().isnumeric()):
            for x in range(int(self.dockwidget.txtRinicial.text()), int(self.dockwidget.txtRfinal.text())+1, int(self.dockwidget.txtRIntervalo.text())):
                if puntoInicio == 0:
                    intervalos = intervalos + str(x)
                    puntoInicio = 1
                else:
                    intervalos = intervalos + "," + str(x)
        #Verifica que el valor ingresado como intervalo sea un número
        elif(self.dockwidget.txtRIntervalo.text().isnumeric() == False):
            QMessageBox.warning(self.iface.mainWindow(), "Aviso", "Ingrese un intervalo numérico.")
        #Alerta sobre la necesidad de usar una letra en el primer valor del intervalo
        elif(self.dockwidget.txtRinicial.text().isnumeric() == False and self.dockwidget.txtRfinal.text().isnumeric() == True):
            QMessageBox.warning(self.iface.mainWindow(), "Aviso", "Si desea crea una cadena de números exteriores con letras consecutivas, por favor, ingrese letra de inicio y fin en orden alfabético.")
        #Alerta sobre la necesidad de usar una letra en el segundo valor del intervalo
        elif(self.dockwidget.txtRinicial.text().isnumeric() == True and self.dockwidget.txtRfinal.text().isnumeric() == False):
            QMessageBox.warning(self.iface.mainWindow(), "Aviso", "Si desea crea una cadena de números exteriores con letras consecutivas, por favor, ingrese letra de inicio y fin en orden alfabético.")
        #Crea la cadena de números exteriores usando una letra para los casos 1A, 1B,1C...
        elif(self.dockwidget.txtRinicial.text().isnumeric() == False and self.dockwidget.txtRfinal.text().isnumeric() == False):
            letraInicio = re.findall(r'\D',self.dockwidget.txtRinicial.text())
            letraFinal = re.findall(r'\D',self.dockwidget.txtRfinal.text())
            numInicio = self.dockwidget.txtRinicial.text().split(letraInicio[0])[0]
            numFinal = self.dockwidget.txtRfinal.text().split(letraFinal[0])[0]
            posInicial = ord(letraInicio[0].upper())
            posFinal = ord(letraFinal[0].upper())
            if numInicio == numFinal:
                for i in range(posInicial, posFinal + 1, 1):
                    intervaloAlfa = intervaloAlfa + (numInicio + '' + chr(i) + ',')
            else:
                for i in range(int(numInicio),int(numInicio)+1,1):
                    for j in range(posInicial, 91, 1):
                        intervaloAlfa = intervaloAlfa + (str(i) + '' + chr(j) + ',')
                for i in range(int(numInicio)+1,int(numFinal),1):
                    for j in range(65, 91, 1):
                        intervaloAlfa = intervaloAlfa + (str(i) + '' + chr(j) + ',')
                for i in range(int(numFinal),int(numFinal)+1,1):
                    for j in range(int(65), posFinal + 1, 1):
                        intervaloAlfa = intervaloAlfa + (str(i) + '' + chr(j) + ',')
            intervalos = intervaloAlfa.rstrip(',')
        #self.dockwidget.textEdit.setText(''.join(intervalos))
        cadena1 = self.dockwidget.textEdit.toPlainText()
        if cadena1 == "":
            self.dockwidget.textEdit.setText(intervalos)
        else:
            self.dockwidget.textEdit.setText(cadena1 + "," + intervalos)

    def btnLimpiarIntervalo(self):

        self.dockwidget.txtRinicial.setText("")
        self.dockwidget.txtRfinal.setText("")
        self.dockwidget.txtRIntervalo.setText("")       
       
    def btnIdentificar10_accion(self):
        
        #limpiar datos en combo mediante consulta
        self.dockwidget.idVialidad.clear()

        
        #Abrir base
        usr = self.dockwidget.txtUsuario.text()
        pwd = self.dockwidget.txtClave.text()
        
        #localhost
        #conn = psycopg2.connect(database="ECEG", user=usr, password=pwd, host="localhost", port="5432")
        #remote Samge bged 
        conn = psycopg2.connect(database=self.baseDatos, user=usr, password=pwd, host=self.servidor, port="5432")
    
        with conn:
            #qry_c = """SELECT * from "01"."SECCION_INE";"""
            #qry_c = "SELECT * from bged.numeros_exteriores where id = %s;" 
            qry_c = "select via.id, via.nombre from bged.numeros_exteriores numext, bged.vialidad via where numext.id = %s and st_intersects(st_buffer(numext.geom, 20, 'side=both'), via.geom);"
            data_c = (self.campo01, )
            with conn.cursor() as curs:
                #self.iface.messageBar().pushMessage("Mensaje", "Se llego al codigo para crear la consulta")
                curs.execute(qry_c, data_c)
                #curs.execute(qry_c)
                #self.iface.messageBar().pushMessage("Mensaje", "Se ejecuto la consulta")
                #result = curs.fetchone()
                #if result == None:
                    #QMessageBox.information(self.iface.mainWindow(), "No hay extracción","No hay elementos que importar...")
                    #return
                #else:
                
                rows = curs.fetchall() #one row
                for row in rows:
                    #self.iface.messageBar().pushMessage("Datos row  ", str(row[0]))
                    idname = str(row[0]) + " : " + row[1].title()
                    self.dockwidget.idVialidad.addItem(idname)


        conn.close()



    def btnIdentificar20_accion(self):
        
        #limpiar datos en combo mediante consulta
        self.dockwidget.idVialidad.clear()
        
        #Abrir base
        usr = self.dockwidget.txtUsuario.text()
        pwd = self.dockwidget.txtClave.text()
        
        #localhost
        #conn = psycopg2.connect(database="ECEG", user=usr, password=pwd, host="localhost", port="5432")
        #remote Samge bged 
        conn = psycopg2.connect(database=self.baseDatos, user=usr, password=pwd, host=self.servidor, port="5432")
    
        with conn:
            #qry_c = """SELECT * from "01"."SECCION_INE";"""
            #qry_c = "SELECT * from bged.numeros_exteriores where id = %s;" 
            qry_c = "select via.id, via.nombre from bged.numeros_exteriores numext, bged.vialidad via where numext.id = %s and st_intersects(st_buffer(numext.geom, 60, 'side=both'), via.geom);"
            data_c = (self.campo01, )
            with conn.cursor() as curs:
                #self.iface.messageBar().pushMessage("Mensaje", "Se llego al codigo para crear la consulta")
                curs.execute(qry_c, data_c)
                #curs.execute(qry_c)
                #self.iface.messageBar().pushMessage("Mensaje", "Se ejecuto la consulta")
                #result = curs.fetchone()
                #if result == None:
                    #QMessageBox.information(self.iface.mainWindow(), "No hay extracción","No hay elementos que importar...")
                    #return
                #else:
                
                rows = curs.fetchall() #one row
                for row in rows:
                    #self.iface.messageBar().pushMessage("Datos row  ", str(row[0]))
                    idname = str(row[0]) + " : " + row[1].title()
                    self.dockwidget.idVialidad.addItem(idname)


        conn.close()

    def btndistUsuario_accion(self):
        
        #Abrir base
        usr = self.dockwidget.txtUsuario.text()
        pwd = self.dockwidget.txtClave.text()
        distUsuario = self.dockwidget.distUsuario.text()
        
        #localhost
        #remote Samge bged 
        if len(distUsuario) >= 1:

            conn = psycopg2.connect(database=self.baseDatos, user=usr, password=pwd, host=self.servidor, port="5432")

            with conn:
            
                qry_c = "select via.id, via.nombre from bged.numeros_exteriores numext, bged.vialidad via where numext.id = %s and st_intersects(st_buffer(numext.geom, {0}, 'side=both'), via.geom);".format(distUsuario)
                data_c = (self.campo01, )
                with conn.cursor() as curs:

                    curs.execute(qry_c, data_c)
                    rows = curs.fetchall() #one row
                    if len(rows) == 0:
                        QMessageBox.warning(self.iface.mainWindow(),"Aviso","La distancia no arrojo ningún resultado. Por favor, intente con una mayor o verifique que la cartografía esté actualizada.")
                    else:
                        for row in rows:
                            #self.iface.messageBar().pushMessage("Datos row  ", str(row[0]))
                            idname = str(row[0]) + " : " + row[1].title()
                            self.dockwidget.idVialidad.addItem(idname)
            conn.close()

        elif len(distUsuario) == 0:
            QMessageBox.warning(self.iface.mainWindow(),"Alerta","No ha ingresado una distancia o es invalida.")

    def cveSector_changed(self):
        numero = 1
        self.dockwidget.txtNombreSector.setText(self.SectorNombre[int(self.dockwidget.cveSector.currentText())-1])
        self.dockwidget.txtRinicial_2.setText(self.SectorRInicial[int(self.dockwidget.cveSector.currentText())-1])
        self.dockwidget.txtRfinal_2.setText(self.SectorRFinal[int(self.dockwidget.cveSector.currentText())-1])
        self.dockwidget.txtRIntervalo_2.setText(self.SectorRIntervalo[int(self.dockwidget.cveSector.currentText())-1])

        if (int(self.dockwidget.cveSector.currentText()) == 1):
            self.dockwidget.textEdit.setText(str(self.Sector1))
        if (int(self.dockwidget.cveSector.currentText()) == 2):
            self.dockwidget.textEdit.setText(str(self.Sector2))
        if (int(self.dockwidget.cveSector.currentText()) == 3):
            self.dockwidget.textEdit.setText(str(self.Sector3))




    def btnAsignarSector_accion(self):
        numero = 1
        intervalos = ""
        puntoInicio = 0
        
        if self.dockwidget.txtNombreSector.text() != "":
            self.SectorNombre[int(self.dockwidget.cveSector.currentText())-1] = self.dockwidget.txtNombreSector.text()
            
            if self.dockwidget.txtRinicial_2.text() != "" and self.dockwidget.txtRfinal_2.text() != "" and self.dockwidget.txtRIntervalo_2.text() != "":

                self.SectorRInicial[int(self.dockwidget.cveSector.currentText())-1] = self.dockwidget.txtRinicial_2.text()
                self.SectorRFinal[int(self.dockwidget.cveSector.currentText())-1] = self.dockwidget.txtRfinal_2.text()
                self.SectorRIntervalo[int(self.dockwidget.cveSector.currentText())-1] = self.dockwidget.txtRIntervalo_2.text()

                for x in range(int(self.dockwidget.txtRinicial_2.text()), int(self.dockwidget.txtRfinal_2.text())+1, int(self.dockwidget.txtRIntervalo_2.text())):
                    if puntoInicio == 0:
                        intervalos = intervalos + str(x)
                        puntoInicio = 1

                        if (int(self.dockwidget.cveSector.currentText()) == 1):
                            self.Sector1.append(str(x))
                        if (int(self.dockwidget.cveSector.currentText()) == 2):
                            self.Sector2.append(str(x))
                        if (int(self.dockwidget.cveSector.currentText()) == 3):
                            self.Sector3.append(str(x))

                    else:
                        intervalos = intervalos + "," + str(x)
                        appendString = "," + str(x)

                        if (int(self.dockwidget.cveSector.currentText()) == 1):
                            self.Sector1.append(appendString)
                        if (int(self.dockwidget.cveSector.currentText()) == 2):
                            self.Sector2.append(appendString)
                        if (int(self.dockwidget.cveSector.currentText()) == 3):
                            self.Sector3.append(appendString)

                        #self.Sector[int(self.dockwidget.cveSector.currentText())-1].append(appendString)

                if (int(self.dockwidget.cveSector.currentText()) == 1):
                    self.dockwidget.textEdit.setText(str(self.Sector1))
                if (int(self.dockwidget.cveSector.currentText()) == 2):
                    self.dockwidget.textEdit.setText(str(self.Sector2))
                if (int(self.dockwidget.cveSector.currentText()) == 3):
                    self.dockwidget.textEdit.setText(str(self.Sector3))

                #self.dockwidget.textEdit.setText(str(self.Sector1[int(self.dockwidget.cveSector.currentText())-1]))
                #self.dockwidget.textEdit.setText(str(self.Sector1))
                #QMessageBox.warning(self.iface.mainWindow(), "Aviso","Arreglo del sector1: " + str(self.Sector1))
                
            else:
                QMessageBox.warning(self.iface.mainWindow(), "Aviso","No se tienen todos los datos del rango inicio, final e intervalo, El Sector es: " + self.dockwidget.cveSector.currentText())
                return
        else:
            QMessageBox.warning(self.iface.mainWindow(), "Aviso","No se tiene nombre del sector: " + self.dockwidget.cveSector.currentText())
            return

    def btnEliminarSector_accion(self):
        numero = 1
        #self.Sector[int(self.dockwidget.cveSector.currentText())].clear()
        
        if (int(self.dockwidget.cveSector.currentText()) == 1):
            self.Sector1.clear()
            self.SectorRInicial[0]=""
            self.SectorRFinal[0]=""
            self.SectorRIntervalo[0]=""
        if (int(self.dockwidget.cveSector.currentText()) == 2):
            self.Sector2.clear()
            self.SectorRInicial[1]=""
            self.SectorRFinal[1]=""
            self.SectorRIntervalo[1]=""

        if (int(self.dockwidget.cveSector.currentText()) == 3):
            self.Sector3.clear()
            self.SectorRInicial[2]=""
            self.SectorRFinal[2]=""
            self.SectorRIntervalo[2]=""


        self.SectorNombre[int(self.dockwidget.cveSector.currentText())-1] = ""
        
        self.dockwidget.txtNombreSector.setText("")
        self.dockwidget.txtRinicial_2.setText("")
        self.dockwidget.txtRfinal_2.setText("")
        self.dockwidget.txtRIntervalo_2.setText("")

    def btnCrearCadena_2_accion(self):
        numero = 1

        intervalos = ""
        puntoInicio = 0
        #btnCrearCadena

        if (self.SectorNombre[0] != "" and self.SectorNombre[1] != "" and self.SectorNombre[2] != ""):
            for i in range(len(self.Sector1)):
                if puntoInicio == 0:
                    for j in range(len(self.Sector2)):
                        for k in range(len(self.Sector3)):
                            intervalos = intervalos + self.SectorNombre[0] + self.Sector1[i].replace(',', '') + " " + self.SectorNombre[1] + self.Sector2[j].replace(',', '') + " " + self.SectorNombre[2] + self.Sector3[k].replace(',', '') + ","
                            #QMessageBox.warning(self.iface.mainWindow(), "Aviso","Se llega aqui con un sector " + self.dockwidget.cveSector.currentText())
        
        if (self.SectorNombre[0] != "" and self.SectorNombre[1] == "" and self.SectorNombre[2] == ""):
            for i in range(len(self.Sector1)):
                if puntoInicio == 0:
                    intervalos = intervalos + self.SectorNombre[0] + self.Sector1[i].replace(',', '') + ","
                    #for j in range(len(self.Sector2)):
                        #for k in range(len(self.Sector3)):
                            #intervalos = intervalos + self.SectorNombre[0] + self.Sector1[i].replace(',', '') + " " + self.SectorNombre[1] + self.Sector2[j].replace(',', '') + " " + self.SectorNombre[2] + self.Sector3[k].replace(',', '') + ","
                            #QMessageBox.warning(self.iface.mainWindow(), "Aviso","Se llega aqui con un sector " + self.dockwidget.cveSector.currentText())
        
        if (self.SectorNombre[0] == "" and self.SectorNombre[1] != "" and self.SectorNombre[2] == ""):
            #for i in range(len(self.Sector1)):
                if puntoInicio == 0:
                    for j in range(len(self.Sector2)):
                        intervalos = intervalos + self.SectorNombre[1] + self.Sector2[j].replace(',', '') + ","
                        #for k in range(len(self.Sector3)):
                            #intervalos = intervalos + self.SectorNombre[0] + self.Sector1[i].replace(',', '') + " " + self.SectorNombre[1] + self.Sector2[j].replace(',', '') + " " + self.SectorNombre[2] + self.Sector3[k].replace(',', '') + ","
                            #QMessageBox.warning(self.iface.mainWindow(), "Aviso","Se llega aqui con un sector " + self.dockwidget.cveSector.currentText())

        if (self.SectorNombre[0] == "" and self.SectorNombre[1] == "" and self.SectorNombre[2] != ""):
            #for i in range(len(self.Sector1)):
                if puntoInicio == 0:
                    #for j in range(len(self.Sector2)):
                        for k in range(len(self.Sector3)):
                            intervalos = intervalos + self.SectorNombre[2] + self.Sector3[k].replace(',', '') + ","
                            #QMessageBox.warning(self.iface.mainWindow(), "Aviso","Se llega aqui con un sector " + self.dockwidget.cveSector.currentText())

        if (self.SectorNombre[0] != "" and self.SectorNombre[1] != "" and self.SectorNombre[2] == ""):
            for i in range(len(self.Sector1)):
                if puntoInicio == 0:
                    for j in range(len(self.Sector2)):
                        intervalos = intervalos + self.SectorNombre[0] + self.Sector1[i].replace(',', '') + " " + self.SectorNombre[1] + self.Sector2[j].replace(',', '') + ","
                        #for k in range(len(self.Sector3)):
                            #intervalos = intervalos + self.SectorNombre[0] + self.Sector1[i].replace(',', '') + " " + self.SectorNombre[1] + self.Sector2[j].replace(',', '') + " " + self.SectorNombre[2] + self.Sector3[k].replace(',', '') + ","
                            #QMessageBox.warning(self.iface.mainWindow(), "Aviso","Se llega aqui con un sector " + self.dockwidget.cveSector.currentText())

        if (self.SectorNombre[0] == "" and self.SectorNombre[1] != "" and self.SectorNombre[2] != ""):
            #for i in range(len(self.Sector1)):
                if puntoInicio == 0:
                    for j in range(len(self.Sector2)):
                        for k in range(len(self.Sector3)):
                            intervalos = intervalos + self.SectorNombre[1] + self.Sector2[j].replace(',', '') + " " + self.SectorNombre[2] + self.Sector3[k].replace(',', '') + ","
                            #QMessageBox.warning(self.iface.mainWindow(), "Aviso","Se llega aqui con un sector " + self.dockwidget.cveSector.currentText())

        if (self.SectorNombre[0] != "" and self.SectorNombre[1] == "" and self.SectorNombre[2] != ""):
            for i in range(len(self.Sector1)):
                if puntoInicio == 0:
                    #for j in range(len(self.Sector2)):
                        for k in range(len(self.Sector3)):
                            intervalos = intervalos + self.SectorNombre[0] + self.Sector1[i].replace(',', '') + " " + self.SectorNombre[2] + self.Sector3[k].replace(',', '') + ","
                            #QMessageBox.warning(self.iface.mainWindow(), "Aviso","Se llega aqui con un sector " + self.dockwidget.cveSector.currentText())

        if (self.SectorNombre[0] == "" and self.SectorNombre[1] == "" and self.SectorNombre[2] == ""):
            QMessageBox.warning(self.iface.mainWindow(), "Aviso","No se ha capturado ningún sector, por favor capture al menos uno.")
                            

        
        
        
        #for i in range(len(self.Sector1)):
        #    intervalos  = intervalos + self.SectorNombre[0] +  self.Sector1[i].replace(',', '')  + " "
        #    intervalos = intervalos + str(i) + " "

        self.dockwidget.textEdit.setText(intervalos)

            #    puntoInicio = 1
            #else:
            #    intervalos = intervalos + "," + str(x)

        #for x in range(int(self.dockwidget.txtRinicial_2.text()), int(self.dockwidget.txtRfinal_2.text())+1, int(self.dockwidget.txtRIntervalo_2.text())):
        #    if puntoInicio == 0:
        #        intervalos = intervalos + str(x)
        #        puntoInicio = 1
        #    else:
        #        intervalos = intervalos + "," + str(x)
                
        #self.dockwidget.textEdit.setText(''.join(intervalos))
        #cadena1 = self.dockwidget.textEdit.toPlainText()
        #cadena1=""
        #if cadena1 == "":
        #    self.dockwidget.textEdit.setText(intervalos)
        #else:
        #    self.dockwidget.textEdit.setText(cadena1 + "," + intervalos)




      
        
    #def btnCancelar_accion(self):
    #    self.dockwidget.close()