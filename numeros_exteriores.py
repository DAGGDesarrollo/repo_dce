# -*- coding: utf-8 -*-
"""
/***************************************************************************
Números Exteriores - INE
                                 A QGIS plugin
 Este Plugin otorga herramientas para el procesamiento, depuración y actualización 
 de los números exteriores pertenecientes a la cartografía electoral generada para 
 la Dirección de Cartografía Electoral del Instituto Nacional Electoral (INE).
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-04-25
        git sha              : $Format:%H$
        copyright            : (C) 2023 by INE, Direccion de Cartografia Electoral, 
                                Luis Enrique Cortés
        email                : enrique.cortes@ine.mx
        version              : 3.0
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.PyQt.QtCore import QSettings, QTranslator,qVersion, Qt, QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtGui import QColor
from qgis.PyQt.QtWidgets import QAction, QMessageBox, QProgressBar, QSizePolicy, QWidget, QApplication
from qgis.core import *
from qgis.core import QgsProject
from qgis.core import QgsVectorLayer, QgsDataSourceUri
from qgis.utils import *
from PyQt5 import QtTest
from PyQt5.QtWidgets import *

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .numeros_exteriores_dockwidget import numeros_exterioresDockWidget
import os
import os.path


#Importa módulo regex para expresiones regulares
import re

# load the adapter
import psycopg2
# load the psycopg extras module
import psycopg2.extras

from qgis.core import QgsApplication;
from qgis.gui import QgsMapCanvas;


class numeros_exteriores:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'numeros_exteriores_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Números Exteriores')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'Números Exteriores')
        self.toolbar.setObjectName(u'Números Exteriores')

        self.campo01 = ""
        self.conectado = False
        self.ultimaEntidad = ""
        self.ultimoMunicipio = ""

        self.servidor = ''
        self.baseDatos = ''

        self.pluginIsActive = False
        self.dockwidget = None

        self.SectorNombre = ['', '', '']
        self.SectorRInicial = ['', '', '']
        self.SectorRFinal = ['', '', '']
        self.SectorRIntervalo = ['', '', '']


        self.Sector1 = []
        self.Sector2 = []
        self.Sector3 = []

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('numeros_exteriores', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """



        #linea agregada al codigo original
        self.dockwidget = numeros_exterioresDockWidget() #Se instancia la clase del cuadro de dialogo
 
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/numeros_exteriores/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Números Exteriores'),
            callback=self.run,
            parent=self.iface.mainWindow())

    #--------------------------------------------------------------------------



        self.dockwidget.btnConectar.clicked.connect(self.btnConectar_accion)
        self.dockwidget.btnDesconectar.clicked.connect(self.btnDesconectar_accion)

        self.dockwidget.cveMunicipio.currentIndexChanged.connect(self.on_cveMunicipio_changed)
        self.dockwidget.btnObtenerArea.clicked.connect(self.btnObtenerArea_accion)

        self.dockwidget.btnRecomendaciones.clicked.connect(self.btnRecomendaciones_accion)

        self.dockwidget.btnMostrar.clicked.connect(self.btnMostrar_accion)
        self.dockwidget.btnSugerir.clicked.connect(self.btnSugerir_accion)
        
        self.dockwidget.tmaxFont.clicked.connect(self.tmaxFont)
        self.dockwidget.tmedFont.clicked.connect(self.tmedFont)
        self.dockwidget.tminFont.clicked.connect(self.tminFont)

        self.dockwidget.btnInvertir.clicked.connect(self.btnInvertir)
        self.dockwidget.btnCrearCadena.clicked.connect(self.btnCrearCadena)
        self.dockwidget.btnGuardar.clicked.connect(self.btnGuardar)
        self.dockwidget.btnLimpiarIntervalo.clicked.connect(self.btnLimpiarIntervalo)
        
        self.dockwidget.btnIdentificar10.clicked.connect(self.btnIdentificar10_accion)
        self.dockwidget.btnIdentificar20.clicked.connect(self.btnIdentificar20_accion)
        self.dockwidget.btnIdentificar10.clicked.connect(self.btnIdentificar10_accion)
        self.dockwidget.btndistUsuario.clicked.connect(self.btndistUsuario_accion)

        self.dockwidget.cveSector.currentIndexChanged.connect(self.cveSector_changed)
        self.dockwidget.btnAsignarSector.clicked.connect(self.btnAsignarSector_accion)
        self.dockwidget.btnEliminarSector.clicked.connect(self.btnEliminarSector_accion)

        self.dockwidget.btnCrearCadena_2.clicked.connect(self.btnCrearCadena_2_accion)
        
        #self.dockwidget.btnCancelar.clicked.connect(self.btnCancelar_accion)


    #--------------------------------------------------------------------------
        
    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING NUMEROS_EXTERIORES"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD numeros_exteriores"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&numeros_exteriores'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    #--------------------------------------------------------------------------

    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = numeros_exterioresDockWidget()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            self.dockwidget.show()

            if self.dockwidget.cveEntidad.count() == 0 :

                for entidad in range(1,33):
                    self.dockwidget.cveEntidad.addItem(str(entidad).zfill(2))

            self.dockwidget.btnDesconectar.setEnabled(False)

            if self.dockwidget.cveSector.count() == 0:
                for sector in range(1,4):
                    item = str(sector)
                    self.dockwidget.cveSector.addItem(item)     

    #lineas agregadas al codigo original
    def btnConectar_accion(self):

        if self.conectado == True:
            return
           
        usr = self.dockwidget.txtUsuario.text()
        pwd = self.dockwidget.txtClave.text()
        
        self.baseDatos = "bged" + self.dockwidget.cveEntidad.currentText()
        self.servidor = self.dockwidget.txtServidor.text()

        
        if usr is NULL or usr == "" or usr.isspace():

            QMessageBox.warning(self.iface.mainWindow(), "Aviso", "No fue posible ingresar a la base, por favor, revise sus credenciales.")
            return None     #Realmente sale de la funcion
            
        if pwd is NULL or pwd == "" or pwd.isspace():

            QMessageBox.warning(self.iface.mainWindow(), "Aviso", "No fue posible ingresar a la base, por favor, revise sus credenciales.")
            return None
 
                
        try:
            
            usr = self.dockwidget.txtUsuario.text()
            pwd = self.dockwidget.txtClave.text()
            
            uri = QgsDataSourceUri()
            # set host name, port, database name, username and password
            uri.setConnection(self.servidor, "5432", self.baseDatos, usr, pwd)
            #Codigo para cargar registros de municipios
            #Abrir base
            usr = self.dockwidget.txtUsuario.text()
            pwd = self.dockwidget.txtClave.text()
            
            #localhost
            #remote Samge bged 
            conn = psycopg2.connect(database=self.baseDatos, user=usr, password=pwd, host=self.servidor, port="5432")
        
            with conn:

                qry_c = "SELECT municipio, nombre from bged.municipio order by municipio asc;"
                data_c = (self.campo01, )
                with conn.cursor() as curs:
                    curs.execute(qry_c)
                    n = 1
                    rows = curs.fetchall() #one row
                    for row in rows:

                        idname = str(row[0]) + " : " + row[1].title()
                        self.dockwidget.cveMunicipio.addItem(idname)
                        n=n+1

                curs.close()

            conn.close()

            self.dockwidget.btnDesconectar.setEnabled(True)
            self.dockwidget.btnConectar.setEnabled(False)
            self.conectado = True

            self.dockwidget.txtServidor.setEnabled(False)
            self.dockwidget.cveEntidad.setEnabled(False)
            self.dockwidget.txtUsuario.setEnabled(False)
            self.dockwidget.txtClave.setEnabled(False)

            QMessageBox.information(self.iface.mainWindow(), "Aviso", "Se realizó la conexión con éxito...\nIP: " + self.servidor + "\nBase de datos: " + self.baseDatos + "\nBienvenido " + usr.split(".")[0].title())

            return None
        except:
            self.iface.messageBar().pushMessage("Mensaje", "No se logró ingresar a la Base.")
            QMessageBox.warning(self.iface.mainWindow(), "Aviso", "No fue posible ingresar a la base, revise los datos, su conexión de red o sus credenciales.")
            return None
        
    
         
    def btnDesconectar_accion(self):

        usuario = self.dockwidget.txtUsuario.text()
        buttonReply = QMessageBox.question(self.iface.mainWindow(), 'Atención', "¿Confirma que desea cerrar su sesión?", QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
        if buttonReply == QMessageBox.Yes:
            if self.conectado == True:

                self.ultimaEntidad = self.dockwidget.cveEntidad.currentText()

                self.dockwidget.txtServidor.setText("")
                self.dockwidget.txtUsuario.setText("")
                self.dockwidget.txtClave.setText("")

                self.dockwidget.idVialidad_original.setText("")
                self.dockwidget.idManzana_original.setText("")

                self.dockwidget.txtRinicial.setText("")
                self.dockwidget.txtRfinal.setText("")
                self.dockwidget.txtRIntervalo.setText("")

                self.dockwidget.txtServidor.setEnabled(True)
                self.dockwidget.cveEntidad.setEnabled(True)
                self.dockwidget.txtUsuario.setEnabled(True)
                self.dockwidget.txtClave.setEnabled(True)

                self.dockwidget.cveMunicipio.clear()
                self.dockwidget.cveSeccion.clear()

                self.dockwidget.btnDesconectar.setEnabled(False)
                self.dockwidget.btnConectar.setEnabled(True)      

                self.conectado = False
                self.iface.mainWindow().show()
                QMessageBox.information(self.iface.mainWindow(),'Información','Se ha cerrado la sesión. \nHasta pronto {0}'.format(usuario.split('.')[0].title()))
        else:
            pass

    def on_cveMunicipio_changed(self, value):      
        
        self.dockwidget.cveSeccion.clear()   
       
        try:
        
            if self.dockwidget.cveMunicipio.count() == 0:
                return
    

            numeroMunicipio = str(self.dockwidget.cveMunicipio.currentText().split(" :",1)[0])
            
            usr = self.dockwidget.txtUsuario.text()
            pwd = self.dockwidget.txtClave.text()
            
            uri = QgsDataSourceUri()
            # set host name, port, database name, username and password
            uri.setConnection(self.servidor, "5432", self.baseDatos, usr, pwd)
          
            #localhost
            #remote Samge bged 
            connectDB = psycopg2.connect(database=self.baseDatos, user=usr, password=pwd, host=self.servidor, port="5432")
     
            conn = psycopg2.connect(database=self.baseDatos, user=usr, password=pwd, host=self.servidor, port="5432")
            with conn:

                qry_c = "SELECT municipio, seccion from bged.seccion where municipio = %s order by seccion asc;"
                data_c = (numeroMunicipio, )

                with conn.cursor() as curs:

                    curs.execute(qry_c, data_c)  
                    rows = curs.fetchall() #one row
                    for row in rows:

                        sec_num = str(row[1])
                        self.dockwidget.cveSeccion.addItem(sec_num)

                curs.close()    
            conn.close()
            return None

        except:
            
            QMessageBox.warning(self.iface.mainWindow(), "Aviso", "No se logró obtener los datos de las secciones de acuerdo con el municipio seleccionado, revise sus credenciales o su conexión a internet.")

            return None


    def btnObtenerArea_accion(self):

        try:

            #Se configura la barra de progreso y se fija el valor inicial en 0 para comenzar el proceso
            prog = QProgressDialog('Cargando capas. Un momento, por favor.', '', 0, 100)
            prog.setWindowModality(Qt.WindowModal)
            prog.setCancelButton(None)
            time.sleep(1)

            #Borrar capas si hubo cambio de entidad
            municipioActual = str(self.dockwidget.cveMunicipio.currentText().split(" :",1)[0])
            if self.dockwidget.cveEntidad.currentText() != self.ultimaEntidad  or self.ultimoMunicipio != municipioActual:
                #borrar capas
                # Get list of vector layers
                layers = list(QgsProject.instance().mapLayers().values())
                # Check there is at least one vector layer. Selecting within the same layer is fine.
                for layer in layers:
                    if layer.type() == QgsMapLayer.VectorLayer:
                        QgsProject.instance().removeMapLayer(layer)

                self.ultimaEntidad = self.dockwidget.cveEntidad.currentText()
                self.ultimoMunicipio = municipioActual

            
            # Get list of vector layers
            layers = list(QgsProject.instance().mapLayers().values())
            # Check there is at least one vector layer. Selecting within the same layer is fine.
            vlayer_count = 0
            for layer in layers:
                if layer.type() == QgsMapLayer.VectorLayer:
                    vlayer_count = vlayer_count + 1
                if layer.name() == "SeccionUnica":
                    QgsProject.instance().removeMapLayer(layer)


            numeroSeccion = str(self.dockwidget.cveSeccion.currentText())
            numeroMunicipio = str(self.dockwidget.cveMunicipio.currentText().split(" :",1)[0])


            usr = self.dockwidget.txtUsuario.text()
            pwd = self.dockwidget.txtClave.text()
            
            uri = QgsDataSourceUri()
            # set host name, port, database name, username and password
            uri.setConnection(self.servidor, "5432", self.baseDatos, usr, pwd)
            # set database schema, table name, geometry column and optionally
            # subset (WHERE clause)



            #Capa auxiliar para reconocer la seccion a trabajar
            QtTest.QTest.qWait(100)
            #Consulta de seccion mediante seccion (una seccion para emular zoom en ella)
            uri.setDataSource("bged", "seccion", "geom", "seccion=" + numeroSeccion)
            vlayer1SEC = QgsVectorLayer(uri.uri(False), "SeccionUnica", "postgres")
            QgsProject.instance().addMapLayer(vlayer1SEC)

            QtTest.QTest.qWait(700)

            #funciona para el zoom
            iface.setActiveLayer(vlayer1SEC)
            iface.zoomToActiveLayer()

            #	232	56	69
            QtTest.QTest.qWait(200)

            vlayer1SEC.setOpacity(0.3)

            mySymbol1 = QgsFillSymbol.createSimple({'color':'red', 'color_border':'red', 'width_border':'0.3', 'style':'solid'})
            myRenderer = vlayer1SEC.renderer()
            myRenderer.setSymbol(mySymbol1)

            #Muestra el 20% de avance
            prog.setValue(20)

            vlayer1SEC.triggerRepaint()
            QtTest.QTest.qWait(100)

            #se elimina capa de la unica seccion solo se agrego para emular zoom, ya no se elimina se usa como transparencia
            QtTest.QTest.qWait(200)

            #Estas capas se cargan una sola vez, Seccion, Manzana, Vialidad, Num Ext
            if vlayer_count == 0:

                #Consulta de seccion mediante municipio/seccion
                uri.setDataSource("bged", "seccion", "geom", "municipio=" + numeroMunicipio)
                vlayerSEC = QgsVectorLayer(uri.uri(False), "Seccion", "postgres")
                QgsProject.instance().addMapLayer(vlayerSEC)


                #Se configura el formato de las etiquetas
                SE_layer = QgsPalLayerSettings()
                textFormat = QgsTextFormat()
                textFormat.setColor(Qt.darkRed)
                textFormat.setSize(15)
                textFormat.buffer().setEnabled(True)
                textFormat.buffer().setSize(0.7)
                textFormat.buffer().setColor(QColor('#FFFFFF'))
                SE_layer.setFormat(textFormat)
                SE_layer.fieldName = '\'Sección \n\' || lpad(to_string("seccion"),4,\'0\')' #Sección a cuatro digitos, del tipo 0000
                SE_layer.isExpression = True
                SE_layer.enabled = True
                SE_layer.placement = QgsPalLayerSettings.OverPoint
                SElabels = QgsVectorLayerSimpleLabeling(SE_layer)
                SElabels.drawLabels = True
                vlayerSEC.setLabeling(SElabels)
                vlayerSEC.setLabelsEnabled(True)
                vlayerSEC.setCustomProperty("labeling/drawLabels",  "True") 
                vlayerSEC.triggerRepaint()
                QtTest.QTest.qWait(200)

                mySymbol1 = QgsFillSymbol.createSimple({'color':'red', 'color_border':'red', 'width_border':'0.4', 'style':'no'})
                myRenderer = vlayerSEC.renderer()
                myRenderer.setSymbol(mySymbol1)
                vlayerSEC.triggerRepaint()
                QtTest.QTest.qWait(1000)
                #E83845
                
                #Muestra el 40% de avance
                prog.setValue(40)

                #Cargar capas
                qry_c =  'SELECT * FROM bged.manzana mza, bged.municipio mun where mun.municipio={}.format(numeroMunicipio) and st_intersects(mun.geom, mza.geom)'
                uri.setDataSource("bged", "manzana", "geom", "municipio=" + numeroMunicipio)

                vlayerM = QgsVectorLayer(uri.uri(False), "Manzana", "postgres")
                
                QgsProject.instance().addMapLayer(vlayerM)

                MZ_layer = QgsPalLayerSettings()
                textFormat = QgsTextFormat()
                textFormat.setColor(QColor('#464646')) 
                textFormat.setSize(11) 
                textFormat.buffer().setEnabled(True)
                textFormat.buffer().setColor(QColor('#FFFFFF'))
                textFormat.buffer().setSize(0.7)
                MZ_layer.setFormat(textFormat)
                MZ_layer.fieldName = '\'Mz \nId \' || "id"'
                MZ_layer.isExpression = True
                MZ_layer.enabled = True
                MZ_layer.placement = QgsPalLayerSettings.AroundPoint
                MZlabels = QgsVectorLayerSimpleLabeling(MZ_layer)
                MZlabels.drawLabels = True
                vlayerM.setLabeling(MZlabels)
                vlayerM.setLabelsEnabled(True)
                vlayerM.setCustomProperty("labeling/drawLabels",  "True")
                vlayerM.triggerRepaint()
                QtTest.QTest.qWait(200)

                mySymbol1 = QgsFillSymbol.createSimple({'color':'#289E26', 'color_border':'#237E21', 'width_border':'0.2', 'style':'dense6'})
                myRenderer = vlayerM.renderer()
                myRenderer.setSymbol(mySymbol1)
                vlayerM.triggerRepaint()
                QtTest.QTest.qWait(1500)
                #E83845            prog.setValue(20)

                #Muestra el 60% de avance
                prog.setValue(60) 

                uri.setDataSource("bged", "vialidad", "geom")
                vlayerV = QgsVectorLayer(uri.uri(False), "Vialidad", "postgres")
                QgsProject.instance().addMapLayer(vlayerV)

                V_layer = QgsPalLayerSettings()
                textFormat = QgsTextFormat()
                textFormat.setColor(QColor('#22243B')) 
                textFormat.setSize(11) 
                textFormat.buffer().setEnabled(True)
                textFormat.buffer().setColor(QColor('#FFFFFF'))
                textFormat.buffer().setSize(0.7)
                V_layer.setFormat(textFormat)
                V_layer.fieldName = '\'Id \'||"id" || \' \' || title("nombre")'
                V_layer.isExpression = True
                V_layer.enabled = True
                V_layer.placement = QgsPalLayerSettings.Curved
                Vlabels = QgsVectorLayerSimpleLabeling(V_layer)
                Vlabels.drawLabels = True
                vlayerV.setLabeling(Vlabels)
                vlayerV.setLabelsEnabled(True)
                vlayerV.setCustomProperty("labeling/drawLabels",  "True")
                vlayerV.triggerRepaint()
                QtTest.QTest.qWait(500)

                renderer = vlayerV.renderer()
                symbol1 = QgsLineSymbol.createSimple({'color': '#000000','width':'.3'})
                renderer.setSymbol(symbol1) 
                vlayerV.triggerRepaint()
                QtTest.QTest.qWait(3000)

                #Muestra el 80% de avance
                prog.setValue(80)

                #Consulta de numeros exteriores con campos nulos
                uri.setDataSource("bged", "numeros_exteriores", "geom")
                vlayerNE = QgsVectorLayer(uri.uri(False), "NumerosExteriores", "postgres")
                QgsProject.instance().addMapLayer(vlayerNE)
                QtTest.QTest.qWait(100)

                NE_layer = QgsPalLayerSettings()
                NE_layer.fieldName = 'id'
                NE_layer.enabled = True
                NE_layer.placement = QgsPalLayerSettings.Free
                NElabels = QgsVectorLayerSimpleLabeling(NE_layer)
                NElabels.drawLabels = True
                vlayerNE.setLabeling(NElabels)
                vlayerNE.setLabelsEnabled(True)
                vlayerNE.setCustomProperty("labeling/drawLabels",  "True")
                vlayerNE.triggerRepaint()
                QtTest.QTest.qWait(200)

                renderer = vlayerNE.renderer()
                symbol1 = QgsLineSymbol.createSimple({'color':'#005F00', 'width':'0.3', 'line_style':'dash'})
                renderer.setSymbol(symbol1) 
                vlayerNE.triggerRepaint()
                QtTest.QTest.qWait(3000)

                self.ultimoMunicipio = municipioActual

            
            #Borrar campos de texto en edicion simple
            self.dockwidget.textEdit.setText("")
            self.dockwidget.idManzana.setText("")
            self.dockwidget.idManzana_original.setText("")
            self.dockwidget.idVialidad_original.setText("")  

            #Se ajusta el valor de progreso de 100% para mostrar el fin del proceso
            prog.setValue(100) 
            QMessageBox.information(self.iface.mainWindow(), "Aviso", "Listo, se cargaron las capas del área de trabajo exitosamente.")

        except:

            QMessageBox.warning(self.iface.mainWindow(), "Aviso", "No se logró cargar las capas adecuadamente, revise su conexión a internet.")

            return None
    
    def btnRecomendaciones_accion(self):
        QMessageBox.information(self.iface.mainWindow(), "Aviso", "Para visualizar adecuadamente este Plugin en su pantalla se recomienda utilzar cualquiera de las siguientes resoluciones de pantalla:\n \n-1920 x 1080 \n-2048 x 1152 \n-2560 x 1600.")
        return

        
    def btnMostrar_accion(self):
    
        #pass
        #Probando funcion
        self.campo01 = ""

        #limpiar datos en combo idVialidad e idManzana
        self.dockwidget.idVialidad.clear()
        self.dockwidget.idManzana.setText("")
        
        # Get list of vector layers
        layers = list(QgsProject.instance().mapLayers().values())
        # Check there is at least one vector layer. Selecting within the same layer is fine.
        vlayer_count = 0
        for layer in layers:
            if layer.type() == QgsMapLayer.VectorLayer:
                vlayer_count = vlayer_count + 1

        if vlayer_count > 0:
        
            #Obtener Datos, modificar para activar el layer de numero exteriores, Importante!!! se evita error de seleccion de tramo
            vl = iface.activeLayer()
            capaactiva = vl.name()

            if capaactiva != "NumerosExteriores":
                QMessageBox.warning(self.iface.mainWindow(), "Alerta", "Por favor, seleccione la capa NumerosExteriores, la capa actual es "  + capaactiva)
                return

            # get the list of selected ids 
            ids = vl.selectedFeatureIds()
            
            if len(ids) == 1:
                # create the request with the selected ids
                request = QgsFeatureRequest()
                request.setFilterFids(ids)

                fields = ['id']

                features = vl.getFeatures(request)
                for feature in features:
                    attrs = [feature[field] for field in fields]
                
                self.campo01 = str(attrs[0])
                
            elif len(ids) == 0: 
                QMessageBox.warning(self.iface.mainWindow(), "Verifique","No seleccionó ningún elemento.")	
            else:
                QMessageBox.warning(self.iface.mainWindow(), "Verifique","Debe seleccionar sólo un elemento.")	
        else:
            QMessageBox.warning(self.iface.mainWindow(), "Verifique","No hay capas vectoriales agregadas.")		
        
        
        usr = self.dockwidget.txtUsuario.text()
        pwd = self.dockwidget.txtClave.text()
        
        #localhost
        #remote Samge bged 
        conn = psycopg2.connect(database=self.baseDatos, user=usr, password=pwd, host=self.servidor, port="5432")
          
        with conn:

            qry_c = "SELECT geom, tramo, manzana, vialidad, numext, valida from bged.numeros_exteriores where id = %s;"
            data_c = (self.campo01, )
            with conn.cursor() as curs:

                curs.execute(qry_c, data_c)
      
                
                results = curs.fetchone() #one row

                result01 = results[0]   #geom           tramo
                result02 = results[1]   #tramo          manzana
                result03 = results[2]   #idManzana      vialidad
                result04 = results[3]   #idVialidad     numext
                result05 = results[4]   #idNumExt       valida
                result06 = results[5]   #valida         pro
    
                self.dockwidget.textEdit.setText(result05)
                self.dockwidget.idManzana_original.setText(str(result03))
                self.dockwidget.idVialidad_original.setText(str(result04))
                
        conn.close()

    def btnSugerir_accion(self):

        self.campo01 = ""

        layers = list(QgsProject.instance().mapLayers().values())

        vlayer_count = 0
        for layer in layers:
            if layer.type() == QgsMapLayer.VectorLayer:
                vlayer_count = vlayer_count + 1


        if vlayer_count > 0:
        
            vl = iface.activeLayer()
            capaactiva = vl.name()

            if capaactiva != "NumerosExteriores":
                QMessageBox.warning(self.iface.mainWindow(), "Alerta", "Por favor seleccione la capa NumerosExteriores, la capa actual es "  + capaactiva)
                return

            ids = vl.selectedFeatureIds()
 
            if len(ids) == 1:
   
                request = QgsFeatureRequest()
                request.setFilterFids(ids)

                fields = ['id']

                features = vl.getFeatures(request)
                for feature in features:
                    attrs = [feature[field] for field in fields]
                
                self.campo01 = str(attrs[0])
                

            elif len(ids) == 0: 
                QMessageBox.warning(self.iface.mainWindow(), "Verifique","No seleccionó ningún elemento.")	
            else:
                QMessageBox.warning(self.iface.mainWindow(), "Verifique","Debe seleccionar sólo un elemento.")	
        else:
            QMessageBox.warning(self.iface.mainWindow(), "Verifique","No hay capas vectoriales agregadas.")		
 
        usr = self.dockwidget.txtUsuario.text()
        pwd = self.dockwidget.txtClave.text()

        conn = psycopg2.connect(database=self.baseDatos, user=usr, password=pwd, host=self.servidor, port="5432") 
        #Configura la barra de progreso 
        prog = QProgressDialog('Buscando Id de Manzana. Un momento, por favor.', '', 0, 100)
        prog.setWindowModality(Qt.WindowModal)
        prog.setCancelButton(None)
        time.sleep(2)
        prog.setValue(25)
        #Se conecta a la BD para obtener el id del registro seleccionado de la capa de números exteriores
        with conn:

            qry_c = "SELECT geom, id from bged.numeros_exteriores where id = %s;"
            data_c = (self.campo01, )
            with conn.cursor() as curs:

                prog.setValue(50)
                curs.execute(qry_c, data_c)
                results = curs.fetchone() #one row
                result01 = results[0]   #geom           
                result02 = results[1]   #id

        with conn:

            #Se conecta a ala BD para obtener el id de la manzana que toca o está a 1m del número exterior selccionado
            qry_c = "SELECT a.id as id_mza FROM bged.manzana as a, bged.numeros_exteriores as b WHERE b.id = {0} AND ST_Intersects(ST_Buffer(a.geom,1),b.geom) = 'true';".format(result02)
            data_c = (self.campo01, )
            with conn.cursor() as curs:

                prog.setValue(75)
                curs.execute(qry_c, data_c)
                results = curs.fetchone() #one row
                idmzasug = results[0]   #id           id manzana sugerido

                if (idmzasug is None or idmzasug == ''):
                    QMessageBox.warning(self.iface.mainWindow(), "Aviso","No se encontró ningún id de manzana.")
                      
            self.dockwidget.idManzana.setText(str(idmzasug))
            
            prog.setValue(100)
        #Ajusta el valor al 100% para concluir la barra de progreso
        conn.close()
        
    
    def tmaxFont(self):

        
        f = self.dockwidget.textEdit.font()
        f.setPointSize(18)
        self.dockwidget.textEdit.setFont(f)


        
    def tmedFont(self):

        f = self.dockwidget.textEdit.font()
        f.setPointSize(14)
        self.dockwidget.textEdit.setFont(f)


        
    def tminFont(self):

        
        f = self.dockwidget.textEdit.font()
        f.setPointSize(12)
        self.dockwidget.textEdit.setFont(f)

    
    
    def btnInvertir(self):
    
        cadena = self.dockwidget.textEdit.toPlainText()
        invertida = ','.join((cadena.split(",")[::-1]))
        self.dockwidget.textEdit.setText(invertida)
        
        #btnInvertir
      
    def btnGuardar(self):
    
        #pass
 
        try:

            usr = self.dockwidget.txtUsuario.text()
            pwd = self.dockwidget.txtClave.text()
        
            #localhost
            conn = psycopg2.connect(database=self.baseDatos, user=usr, password=pwd, host=self.servidor, port="5432")
    
            #Grabar a Postgres
            cursor = conn.cursor()
        
            qry = "UPDATE bged.numeros_exteriores set manzana = %s, vialidad = %s, numext = %s where id = %s;"
        

            Id_manzana_actual = self.dockwidget.idManzana_original.text()
            Id_vialidad_actual = self.dockwidget.idVialidad_original.text()
            numeroExterior = self.dockwidget.textEdit.toPlainText()

            #Mostrar variables de datos actuales del numero exterior
            IdNumeroManzana = self.dockwidget.idManzana.text()
            if ' : ' in self.dockwidget.idVialidad.currentText():
                IdNumeroVialidad = str(self.dockwidget.idVialidad.currentText().split(" :",1)[0])
            else:
                IdNumeroVialidad = self.dockwidget.idVialidad.currentText()
           
            if IdNumeroManzana == "":
                if (Id_manzana_actual and not Id_manzana_actual.isspace()) and not Id_manzana_actual == "None":
                    # the string is non-empty
                    QMessageBox.information(self.iface.mainWindow(), "Aviso","No se actualizó el dato de Id manzana, se conserva el actual: " + Id_manzana_actual)
                    IdNumeroManzana = Id_manzana_actual
                else:
                    # the string is empty
                    QMessageBox.warning(self.iface.mainWindow(), "Aviso","Debe ingresar el dato Id manzana actualizado para guardar los cambios.")
                    return
            elif IdNumeroManzana.isnumeric == False:
                QMessageBox.information(self.iface.mainWindow(), "Aviso","Ingrese un Id valido, caracteres especiales o letras no permitidos.\nNo se actualizó el dato de Id manzana, se conserva el actual: " + Id_manzana_actual)
            if IdNumeroVialidad == "":
                if (Id_vialidad_actual and not Id_vialidad_actual.isspace()) and not Id_vialidad_actual == "None":
                    # the string is non-empty
                    QMessageBox.information(self.iface.mainWindow(), "Aviso","No se actualizó el dato de Identificador de Vialidad más cercano, se conserva el actual: " + Id_vialidad_actual)
                    IdNumeroVialidad = Id_vialidad_actual
                else:
                    # the string is empty
                    QMessageBox.warning(self.iface.mainWindow(), "Aviso","Debe ingresar el dato de Identificador de Vialidad más cercano para guardar los cambios.")
                    return
            

            if numeroExterior == "" or numeroExterior == "None":
                # the string is empty
                QMessageBox.warning(self.iface.mainWindow(), "Aviso","Debe ingresar el dato de Número Exterior para guardar los cambios.")
                return

            IdNumeroManzana = IdNumeroManzana.strip()
            IdNumeroVialidad = IdNumeroVialidad.strip()
            numeroExterior = numeroExterior.strip().rstrip(',')

            data = (IdNumeroManzana,IdNumeroVialidad,numeroExterior,self.campo01)
        
        
            cursor.execute(qry,data) 
            conn.commit()
            cursor.close()
            conn.close()         

            #Confirmar
            QMessageBox.information(self.iface.mainWindow(), "Aviso","Se guardaron los cambios exitosamente.")

        except:

            QMessageBox.warning(self.iface.mainWindow(), "Aviso", "No se logró guardar la información, revise los datos capturados, sus credenciales o su conexión a internet.")
            return None

        
    def btnCrearCadena(self):
        
        intervalos = ""
        puntoInicio = 0
        intervaloAlfa = ""
        #btnCrearCadena
        if (self.dockwidget.txtRinicial.text().isnumeric() == True and self.dockwidget.txtRfinal.text().isnumeric() == True and self.dockwidget.txtRIntervalo.text().isnumeric()):
            for x in range(int(self.dockwidget.txtRinicial.text()), int(self.dockwidget.txtRfinal.text())+1, int(self.dockwidget.txtRIntervalo.text())):
                if puntoInicio == 0:
                    intervalos = intervalos + str(x)
                    puntoInicio = 1
                else:
                    intervalos = intervalos + "," + str(x)
        #Verifica que se hayan ingresado todos los datos para gnerar la cadena
        elif (self.dockwidget.txtRinicial.text() == '' or self.dockwidget.txtRfinal.text() == '' or self.dockwidget.txtRIntervalo.text() == ''):
            QMessageBox.warning(self.iface.mainWindow(), "Aviso", "No ha ingresado valor de inicio, final o rango, por favor, ingrese los tres.")
        #Verifica que el valor ingresado como intervalo sea un número
        elif(self.dockwidget.txtRIntervalo.text().isnumeric() == False):
            QMessageBox.warning(self.iface.mainWindow(), "Aviso", "Ingrese un intervalo numérico.")
        #Alerta sobre la necesidad de usar una letra en el primer valor del intervalo
        elif(self.dockwidget.txtRinicial.text().isnumeric() == False and self.dockwidget.txtRfinal.text().isnumeric() == True):
            QMessageBox.warning(self.iface.mainWindow(), "Aviso", "Si desea crea una cadena de números exteriores con letras consecutivas, por favor, ingrese letra de inicio y fin en orden alfabético.")
        #Alerta sobre la necesidad de usar una letra en el segundo valor del intervalo
        elif(self.dockwidget.txtRinicial.text().isnumeric() == True and self.dockwidget.txtRfinal.text().isnumeric() == False):
            QMessageBox.warning(self.iface.mainWindow(), "Aviso", "Si desea crea una cadena de números exteriores con letras consecutivas, por favor, ingrese letra de inicio y fin en orden alfabético.")
        #Crea la cadena de números exteriores usando una letra para los casos 1A, 1B,1C...
        elif(self.dockwidget.txtRinicial.text().isnumeric() == False and self.dockwidget.txtRfinal.text().isnumeric() == False):
            letraInicio = re.findall(r'\D',self.dockwidget.txtRinicial.text())
            letraFinal = re.findall(r'\D',self.dockwidget.txtRfinal.text())
            numInicio = self.dockwidget.txtRinicial.text().split(letraInicio[0])[0]
            numFinal = self.dockwidget.txtRfinal.text().split(letraFinal[0])[0]
            posInicial = ord(letraInicio[0].upper())
            posFinal = ord(letraFinal[0].upper())
            if numInicio == numFinal and posInicial < posFinal:
                for i in range(posInicial, posFinal + 1, 1):
                    intervaloAlfa = intervaloAlfa + (numInicio + '' + chr(i) + ',')
            elif numInicio != numFinal and posInicial < posFinal:
                for i in range(int(numInicio),int(numInicio)+1,1):
                    for j in range(posInicial, 91, 1):
                        intervaloAlfa = intervaloAlfa + (str(i) + '' + chr(j) + ',')
                for i in range(int(numInicio)+1,int(numFinal),1):
                    for j in range(65, 91, 1):
                        intervaloAlfa = intervaloAlfa + (str(i) + '' + chr(j) + ',')
                for i in range(int(numFinal),int(numFinal)+1,1):
                    for j in range(int(65), posFinal + 1, 1):
                        intervaloAlfa = intervaloAlfa + (str(i) + '' + chr(j) + ',')
            elif posInicial > posFinal:
                QMessageBox.warning(self.iface.mainWindow(), "Aviso", "El orden alfabético es descendente, por favor, verifique e intente de nuevo.")
            intervalos = intervaloAlfa.rstrip(',')
        #self.dockwidget.textEdit.setText(''.join(intervalos))
        cadena1 = self.dockwidget.textEdit.toPlainText()
        if cadena1 == "":
            self.dockwidget.textEdit.setText(intervalos)
        elif intervalos == "":
            self.dockwidget.textEdit.setText(cadena1)
        else:
            self.dockwidget.textEdit.setText(cadena1 + "," + intervalos)

    def btnLimpiarIntervalo(self):

        self.dockwidget.txtRinicial.setText("")
        self.dockwidget.txtRfinal.setText("")
        self.dockwidget.txtRIntervalo.setText("")       
       
    def btnIdentificar10_accion(self):
        
        #limpiar datos en combo mediante consulta
        self.dockwidget.idVialidad.clear()

        
        #Abrir base
        usr = self.dockwidget.txtUsuario.text()
        pwd = self.dockwidget.txtClave.text()
        
        #localhost
        conn = psycopg2.connect(database=self.baseDatos, user=usr, password=pwd, host=self.servidor, port="5432")
    
        with conn:

            qry_c = "select via.id, via.nombre from bged.numeros_exteriores numext, bged.vialidad via where numext.id = %s and st_intersects(st_buffer(numext.geom, 20, 'side=both'), via.geom);"
            data_c = (self.campo01, )
            with conn.cursor() as curs:

                curs.execute(qry_c, data_c)              
                rows = curs.fetchall() #one row

                for row in rows:

                    idname = str(row[0]) + " : " + row[1].title()
                    self.dockwidget.idVialidad.addItem(idname)


        conn.close()



    def btnIdentificar20_accion(self):
        
        #limpiar datos en combo mediante consulta
        self.dockwidget.idVialidad.clear()
        
        #Abrir base
        usr = self.dockwidget.txtUsuario.text()
        pwd = self.dockwidget.txtClave.text()
        
        #localhost
        conn = psycopg2.connect(database=self.baseDatos, user=usr, password=pwd, host=self.servidor, port="5432")
    
        with conn:

            qry_c = "select via.id, via.nombre from bged.numeros_exteriores numext, bged.vialidad via where numext.id = %s and st_intersects(st_buffer(numext.geom, 60, 'side=both'), via.geom);"
            data_c = (self.campo01, )
            with conn.cursor() as curs:

                curs.execute(qry_c, data_c)        
                rows = curs.fetchall() #one row

                for row in rows:

                    idname = str(row[0]) + " : " + row[1].title()
                    self.dockwidget.idVialidad.addItem(idname)


        conn.close()

    def btndistUsuario_accion(self):
        
        #Abrir base
        usr = self.dockwidget.txtUsuario.text()
        pwd = self.dockwidget.txtClave.text()
        distUsuario = self.dockwidget.distUsuario.text()

        #localhost
        #remote Samge bged 
        if distUsuario == '':
            QMessageBox.warning(self.iface.mainWindow(),"Alerta","No se ha ingresado una distancia, por favor, ingrese una. \nConsidere que esta debe ser mayor que 60m.")

        elif distUsuario.isnumeric() == False:
            QMessageBox.warning(self.iface.mainWindow(),"Alerta","Eso no es un valor, por favor, ingrese uno.\nConsidere que el valor de distancia debe ser mayor que 60m.")
        
        elif float(distUsuario) <= 60:
            QMessageBox.warning(self.iface.mainWindow(),"Alerta","La distancia ingresada es igual o menor que 60m.")
        
        elif len(distUsuario) >= 2 and float(distUsuario) > 60:

            conn = psycopg2.connect(database=self.baseDatos, user=usr, password=pwd, host=self.servidor, port="5432")

            with conn:

                qry_c = "select via.id, via.nombre from bged.numeros_exteriores numext, bged.vialidad via where numext.id = %s and st_intersects(st_buffer(numext.geom, {0}, 'side=both'), via.geom);".format(distUsuario)
                data_c = (self.campo01, )
                with conn.cursor() as curs:

                    curs.execute(qry_c, data_c)
                    rows = curs.fetchall() #one row
                    if len(rows) == 0:
                        QMessageBox.warning(self.iface.mainWindow(),"Aviso","La distancia no arrojó ningún resultado. Por favor, intente con una mayor o verifique que la cartografía esté actualizada.")
                    else:
                        for row in rows:
      
                            idname = str(row[0]) + " : " + row[1].title()
                            self.dockwidget.idVialidad.addItem(idname)
            conn.close()



    def cveSector_changed(self):
        numero = 1
        self.dockwidget.txtNombreSector.setText(self.SectorNombre[int(self.dockwidget.cveSector.currentText())-1])
        self.dockwidget.txtRinicial_2.setText(self.SectorRInicial[int(self.dockwidget.cveSector.currentText())-1])
        self.dockwidget.txtRfinal_2.setText(self.SectorRFinal[int(self.dockwidget.cveSector.currentText())-1])
        self.dockwidget.txtRIntervalo_2.setText(self.SectorRIntervalo[int(self.dockwidget.cveSector.currentText())-1])

        if (int(self.dockwidget.cveSector.currentText()) == 1):
            self.dockwidget.textEdit.setText(str(self.Sector1))
        if (int(self.dockwidget.cveSector.currentText()) == 2):
            self.dockwidget.textEdit.setText(str(self.Sector2))
        if (int(self.dockwidget.cveSector.currentText()) == 3):
            self.dockwidget.textEdit.setText(str(self.Sector3))




    def btnAsignarSector_accion(self):
        numero = 1
        intervalos = ""
        puntoInicio = 0
        
        if self.dockwidget.txtNombreSector.text() != "":
            self.SectorNombre[int(self.dockwidget.cveSector.currentText())-1] = self.dockwidget.txtNombreSector.text()
            
            if self.dockwidget.txtRinicial_2.text() != "" and self.dockwidget.txtRfinal_2.text() != "" and self.dockwidget.txtRIntervalo_2.text() != "":

                self.SectorRInicial[int(self.dockwidget.cveSector.currentText())-1] = self.dockwidget.txtRinicial_2.text()
                self.SectorRFinal[int(self.dockwidget.cveSector.currentText())-1] = self.dockwidget.txtRfinal_2.text()
                self.SectorRIntervalo[int(self.dockwidget.cveSector.currentText())-1] = self.dockwidget.txtRIntervalo_2.text()

                for x in range(int(self.dockwidget.txtRinicial_2.text()), int(self.dockwidget.txtRfinal_2.text())+1, int(self.dockwidget.txtRIntervalo_2.text())):
                    if puntoInicio == 0:
                        intervalos = intervalos + str(x)
                        puntoInicio = 1

                        if (int(self.dockwidget.cveSector.currentText()) == 1):
                            self.Sector1.append(str(x))
                        if (int(self.dockwidget.cveSector.currentText()) == 2):
                            self.Sector2.append(str(x))
                        if (int(self.dockwidget.cveSector.currentText()) == 3):
                            self.Sector3.append(str(x))

                    else:
                        intervalos = intervalos + "," + str(x)
                        appendString = "," + str(x)

                        if (int(self.dockwidget.cveSector.currentText()) == 1):
                            self.Sector1.append(appendString)
                        if (int(self.dockwidget.cveSector.currentText()) == 2):
                            self.Sector2.append(appendString)
                        if (int(self.dockwidget.cveSector.currentText()) == 3):
                            self.Sector3.append(appendString)


                if (int(self.dockwidget.cveSector.currentText()) == 1):
                    self.dockwidget.textEdit.setText(str(self.Sector1))
                if (int(self.dockwidget.cveSector.currentText()) == 2):
                    self.dockwidget.textEdit.setText(str(self.Sector2))
                if (int(self.dockwidget.cveSector.currentText()) == 3):
                    self.dockwidget.textEdit.setText(str(self.Sector3))
                
            else:
                QMessageBox.warning(self.iface.mainWindow(), "Aviso","No se tienen todos los datos del rango inicio, final e intervalo, El Sector es: " + self.dockwidget.cveSector.currentText())
                return
        else:
            QMessageBox.warning(self.iface.mainWindow(), "Aviso","No se tiene nombre del sector: " + self.dockwidget.cveSector.currentText())
            return

    def btnEliminarSector_accion(self):
        numero = 1
        
        if (int(self.dockwidget.cveSector.currentText()) == 1):
            self.Sector1.clear()
            self.SectorRInicial[0]=""
            self.SectorRFinal[0]=""
            self.SectorRIntervalo[0]=""
        if (int(self.dockwidget.cveSector.currentText()) == 2):
            self.Sector2.clear()
            self.SectorRInicial[1]=""
            self.SectorRFinal[1]=""
            self.SectorRIntervalo[1]=""

        if (int(self.dockwidget.cveSector.currentText()) == 3):
            self.Sector3.clear()
            self.SectorRInicial[2]=""
            self.SectorRFinal[2]=""
            self.SectorRIntervalo[2]=""


        self.SectorNombre[int(self.dockwidget.cveSector.currentText())-1] = ""
        
        self.dockwidget.txtNombreSector.setText("")
        self.dockwidget.txtRinicial_2.setText("")
        self.dockwidget.txtRfinal_2.setText("")
        self.dockwidget.txtRIntervalo_2.setText("")

    def btnCrearCadena_2_accion(self):
        numero = 1

        intervalos = ""
        puntoInicio = 0
        #btnCrearCadena

        if (self.SectorNombre[0] != "" and self.SectorNombre[1] != "" and self.SectorNombre[2] != ""):
            for i in range(len(self.Sector1)):
                if puntoInicio == 0:
                    for j in range(len(self.Sector2)):
                        for k in range(len(self.Sector3)):
                            intervalos = intervalos + self.SectorNombre[0] + self.Sector1[i].replace(',', '') + " " + self.SectorNombre[1] + self.Sector2[j].replace(',', '') + " " + self.SectorNombre[2] + self.Sector3[k].replace(',', '') + ","

        
        if (self.SectorNombre[0] != "" and self.SectorNombre[1] == "" and self.SectorNombre[2] == ""):
            for i in range(len(self.Sector1)):
                if puntoInicio == 0:
                    intervalos = intervalos + self.SectorNombre[0] + self.Sector1[i].replace(',', '') + ","

        
        if (self.SectorNombre[0] == "" and self.SectorNombre[1] != "" and self.SectorNombre[2] == ""):

                if puntoInicio == 0:
                    for j in range(len(self.Sector2)):
                        intervalos = intervalos + self.SectorNombre[1] + self.Sector2[j].replace(',', '') + ","


        if (self.SectorNombre[0] == "" and self.SectorNombre[1] == "" and self.SectorNombre[2] != ""):

                if puntoInicio == 0:

                        for k in range(len(self.Sector3)):
                            intervalos = intervalos + self.SectorNombre[2] + self.Sector3[k].replace(',', '') + ","


        if (self.SectorNombre[0] != "" and self.SectorNombre[1] != "" and self.SectorNombre[2] == ""):
            for i in range(len(self.Sector1)):
                if puntoInicio == 0:
                    for j in range(len(self.Sector2)):
                        intervalos = intervalos + self.SectorNombre[0] + self.Sector1[i].replace(',', '') + " " + self.SectorNombre[1] + self.Sector2[j].replace(',', '') + ","
 

        if (self.SectorNombre[0] == "" and self.SectorNombre[1] != "" and self.SectorNombre[2] != ""):

                if puntoInicio == 0:
                    for j in range(len(self.Sector2)):
                        for k in range(len(self.Sector3)):
                            intervalos = intervalos + self.SectorNombre[1] + self.Sector2[j].replace(',', '') + " " + self.SectorNombre[2] + self.Sector3[k].replace(',', '') + ","


        if (self.SectorNombre[0] != "" and self.SectorNombre[1] == "" and self.SectorNombre[2] != ""):
            for i in range(len(self.Sector1)):
                if puntoInicio == 0:
        
                        for k in range(len(self.Sector3)):
                            intervalos = intervalos + self.SectorNombre[0] + self.Sector1[i].replace(',', '') + " " + self.SectorNombre[2] + self.Sector3[k].replace(',', '') + ","


        if (self.SectorNombre[0] == "" and self.SectorNombre[1] == "" and self.SectorNombre[2] == ""):
            QMessageBox.warning(self.iface.mainWindow(), "Aviso","No se ha capturado ningún sector, por favor, capture al menos uno.")
                                

        self.dockwidget.textEdit.setText(intervalos.rstrip(','))

